<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width" />
		<title>Lesson Transcriptions</title>
	</head>
	<body>
		
    <h2>1. broadcast</h2>
    <p>Hi.
Welcome back to Programming for a Network World.
Today, we're going to be talking about the broadcast block.
The broadcast block allows you to send messages
across projects and let those messages be picked up
by other sprites or blocks.
So when you think about broadcasting in daily life,
if I want to broadcast something to the people around me,
I might shout, here, here.
And then they would look to me to see what I was talking about.
So in Nets blocks, broadcasts work in much the same way.
You can broadcast a message, and then other blocks
will pick up that message and be able to respond to it.
Ready to try out the broadcast block?
Let's get started.
OK, so to get going, we're going to set up
a very simple exercise of just sending a broadcast message
and then receiving that broadcast.
But we're going to do it across two sprites.
So the way we'll begin is we'll set up a message
that Ada will send out.
And if I go over here to the Control palette
and I bring over Broadcast, you see, oh, there we go.
Let's bring over Broadcast.
It has a dropdown.
And I can drop it down, and I can say New.
And it's going to ask me for a message name.
The message name is basically a bare symbol.
It's anything that you want to give it.
And that's what the receiver of the broadcast
will get when the message is sent out.
So it doesn't have any content beyond its name.
That's why I call it a symbol.
So I will just say Broadcast Hello.
And let's put that.
And you'll see that I've got now my Hello message.
And so let's just put When Space is Clicked to get it
a little bit more interesting.
Now, if I just click this right now,
you'll see that it activates, but nothing happens.
And that's simply because we've broadcast this message,
but there's no corresponding receiver
to pick up that message.
So let's bring in another sprite to pick up our message.
I'm going to go over here, and I'm going to create.
Let's see.
We've got to go over here to create a sprite first.
And there it is.
Let's give it a costume.
So I'm going to go over to Costumes.
Always takes a while to open up Costumes.
And there's Alonzo.
And we'll bring up Alonzo on the stage a little bit.
Now, we want Alonzo to receive that message
and then do something in response.
So now we're working inside of Alonzo's script area.
And there is a corresponding block
called When I Receive.
So this hat block can have a dropdown here
that shows it can respond to any message.
So anytime anything happens that's broadcast,
it can respond to it.
Or it can respond to particular types of broadcast messages.
In this case, we're going to use the Hello message.
And so when Alonzo receives the broadcast from Ada,
then Alonzo will respond with whatever
we put under this hat block.
And in this case, why don't we go to a Say block.
And we'll say, hello to you too.
OK.
So now we have a very simple program.
We'll start it off with Ada.
And we'll press the Space key.
And voila, you see.
We'll try it again.
There it is.
Hello to you too.
So Ada broadcast this message hello.
And then inside of our Alonzo script,
we see when I receive hello, say hello to you too.
Now, the way that you use broadcast very often in programs
is to coordinate events that are taking place.
It's very often used, for example, in games.
So when you're working with a game, for example,
you might want to set a condition in which
if two sprites collide with each other,
then the game is over.
And you broadcast to everything else in the game
this game over event.
So that's a very common way of setting this up.
And we can try that ourselves here.
So let's move our scripts off.
And we're going to start again afresh.
Here we go.
And we will set up.
Let's do a little change of our characters.
We'll say goodbye to Ada.
And we'll change Alonzo's costume
into a rocket ship, how about?
So let's go down to costumes again.
And let's take a look.
There's a rocket ship here somewhere.
There's a robot.
That's not too bad.
We could go for that if we can't find the rocket.
Ah, spaceship.
We did get it.
So let's bring that in.
There's a spaceship.
Now, and we want to remove this costume.
So we've got a spaceship.
And let's set up some more sprites, or at least one more.
So we'll create a new one.
And let's give this one a costume
that we create ourselves.
So we'll go over here to paint.
And I'm going to just take this circle like this.
And then maybe we'll color it a little bit differently.
Here we go.
OK.
Now, this is going to be a very simple game.
And you're going to have to expand on this
to make it interesting.
But what we'll do for this sprite, which
we'll call rock or asteroid or something like that,
we'll have this come down from the top of the screen.
And then the rocket will need to avoid it.
And if the rocket collides with it,
then we're going to broadcast the game over event.
OK.
So we're going to take this asteroid.
And we're going to go to a scripting area.
And when we start the game, when the green flag is clicked,
we want to move it to the very top of the screen
and hide it off screen.
All right.
So let's do that.
Hide here.
We're going to find under Looks.
There we go.
We're going to hide it.
We're going to go to, let's say, coordinate x is 0.
And this will be negative 200.
Let's just try that out.
And there we go.
OK, so it's off the screen.
Let's have it go down and see if it can collide with our rocket.
OK.
So we'll take the next thing we want to do is, OK,
we're going to have it glide to a particular direction.
And we're going to have that direction be chosen at random.
So we need to go to Operators and look at Random.
Pick Random here.
OK.
So we'll have it glide.
And let's set our initial time of five seconds.
And then let's have it glide to someplace
on the bottom of the screen, 150, let's say, 200.
OK.
And between this and this, let's just try it out
and see how it works.
And we need to show it, too.
OK, so let's try this.
Let's see how that works.
Oh, we've got it coming from the wrong direction, which
could be a challenge.
So let's switch these.
So this will be 200.
And then we'll try negative 200.
Let's try that.
OK.
So we've got our asteroid coming down.
And it's not going down quite far enough.
We want it to be off screen.
So let's go to negative 250.
And now we just want to put this into some kind of loop,
right, so that we have new asteroids coming down
every time.
And we need to make sure that they change a little bit more
in their direction.
So let's do 150, negative 150 to 150.
Let's see if that works better.
This should make our asteroid do a little bit more
interesting paths at random, going in different directions.
It makes the game a little bit more interesting.
There we go.
And we'll make it a little bit faster.
OK.
So let's put this into a loop.
And we're going to do, let's do a forever block.
So that's down here.
And there we go.
OK, let's just test this out.
It should just keep going.
So we get down to the bottom.
And it goes up to the top again.
And it's going to be picking different directions.
OK.
So we got that piece going.
And now we need to give some controls to the rocket.
So let's get over to the rocket.
And here, with the rocket, we basically
want to respond to the event of moving left and right.
We basically want to respond to the event of moving
left and right.
So when the key is pressed, in this case,
let's just assign this to the left arrow.
Then we want to move, let's see, we'll say, change x here.
That's probably the easiest block to use.
So that's our x-coordinate.
And we're going to change it by negative 5.
Let's just test that out.
So it's moving to the left.
And now if we want to move it to the right,
we can duplicate this, drop this down here,
and put it to the right.
There we go.
OK, so now we've got controls here.
I've got to change this to 5, because otherwise we're
just moving the same direction.
So now we've got controls.
We can move our rocket back and forth.
So in a way, we're ready to play our game, right?
So if we start this with the green flag,
I can move and try to avoid this.
Oh, not so good.
Let me try that again.
Got to move faster.
There we go.
Get back to the center.
Whoa.
OK, so we can play our game.
But you notice there's one problem here.
I mean, to make this a full-fledged game,
there's probably lots of things that we want to add.
But there's one very significant problem,
namely, when this asteroid comes into proximity
with the rocket, nothing happens.
So we need to detect that event.
And then we need to broadcast this game over event
to show that the game has, in fact,
ended when the two objects collide.
So to do that, let's go over to here.
We're back again inside of our rocket sprite.
And we're going to do a sensing block.
And we've got this touching.
So we can drop down, and we can say when.
So this is just detecting that it's touching.
So it's not touching right now.
That's false.
But if we click on it again when they are touching, it's true.
OK, so we'll do another event here under Control.
And this will be when touching.
So when that occurs, we're going to broadcast game over.
So now, let's go back and get a broadcast block.
So we're going to broadcast here.
And we're going to make a new message.
We're going to call it game over.
Here we go.
So now, you'll see, when they're touching,
it will broadcast game over.
But we haven't set anything up on the receiver side yet.
So in this case, if we're running this,
the message is broadcast as soon as the asteroid
touches the rocket.
But nothing stops because we haven't set up
the receiver on the side.
So we need to set up the receiver here.
And let's just do that.
When I receive over here, game over.
Now, we just want to do something
that's going to stop that.
So you'll see that down here, there is a stop all.
And so that will stop the sprite from doing its forever loop.
And so in this case, when the two objects collide,
then it should broadcast game over.
And the other sprite should receive that message.
And stop all.
OK, let's try it.
So here we go.
I'm avoiding.
I'm avoiding.
Oh, I didn't avoid it well enough.
The game is over.
Let's try it again.
Oh, oh.
All right, let's try it one more time.
Here we go.
I just cannot avoid it.
I really want to try to avoid this.
OK, I avoided one successfully.
That's good.
Avoiding another, just barely.
And oh, oh.
It collided.
So you see now that these two sprites
are communicating to each other by broadcasting
these symbols that are picked up.
And then you can respond to those messages that
are broadcast appropriately.
All right, that's it for this time.
We're going to be diving into more complex messages
next time that Nets Blocks enables.
And we'll see you in our next video.
Thank you.
</p>
  

    <h2>2. charts</h2>
    <p>Hello, everyone.
Welcome back to Programming for a Network World.
Today, we're going to continue our exploration
of remote procedure calls, or RPCs.
In this episode, we're going to be looking at data and ways
to visualize data.
It's very common, for example, when you access a data set
that you want to get a visual representation of it.
And fortunately, there's an RPC for that in Nest Blocks.
So ready to visualize some data?
Let's get going.
All right.
So to begin, let's get the data itself.
So the data set that we're going to be using
is a data set collected at the Manaloa Observatory in Hawaii.
This data set tracks the level of carbon dioxide
in the atmosphere.
And the reason that Manaloa is so useful
is that it's on an extinct mountaintop,
and the levels of carbon monoxide
are really unaffected by the environment around it,
which allows you to get kind of an average for the atmosphere
as a whole.
So we have an RPC that reaches out and gets
that historical data, and then brings it back to us
in list form in Nest Blocks.
So let's start there.
We're going to go over to the Network tab here,
and we're going to go to our call block.
And we're going to drop down this call block,
and we're going to go here to Climate.
And then under Climate, you'll see Manaloa carbon dioxide
data.
And as you see here, we can get either the trend
or the raw CO2.
We're going to go with the trend.
And I believe the start year is 1958,
so we'll put that in as the beginning year.
And then the last year that's available to us in Nest Blocks
is 2019.
So we'll use that as our delimiters,
and then we can call this.
And you see that it provides a nice table form of the data
with the year, and the month, and then the recorded level.
OK, so that's great, but it's not easy necessarily
by just looking at this to see what the trend actually
looks like.
So in order to do that, we're going
to use the GNU plot charting service.
This is a free and open source library for plotting data,
and it's available to us again in Nest Blocks.
So if I bring this over here and I drop down to Chart,
you'll see that it brings me a block that has two options.
One is to draw, and the other is default options.
So we can just use it with the default options
and then call with our own data set
and just see how it looks at first.
So I'll bring this in here to Lines.
And then for the options, you still
need to pass something in or do.
Maybe it works without it.
I think it actually worked without it.
So there you go.
If you don't need to change the options,
you can just let it go.
So let's look at this.
In this particular chart, you see
that it's actually too small to look at.
How do we visualize this better?
Well, we do that trick of going up to Looks
and using Switch to Costume.
So Switch to Costume will change the costume
of the sprite on the stage, in this case,
from Ada to the chart itself.
So we can drop that in.
Here we go.
And we can make that call.
And there you can see that already we
got a nice plot of the data.
And unfortunately, as it shows, from 1958 until 2020,
we've increased our carbon dioxide level
in the atmosphere substantially.
Can't do much about that in this particular video.
But we can at least, I think, maybe
label what we're seeing a little bit better.
So to do that, we need to dive back into those options.
So I'm going to bring over another block here.
And we're going to call out to chart.
Oops.
See if I can actually bring it over this time.
There we go.
I'm going to go to chart.
But this time, I'm going to look at the default options.
And if I click on that, you see that it brings me back
another list here in table form.
And it has some possibilities for us
to fill in information, like we can give a title.
And we could perhaps add something
to the y label or the y-axis.
But how do we do that?
We can't just type it in here and have it stick.
We need to first assign this default information
to a variable.
And then we'll change that information.
And then we'll send it back in.
So let's do that by first setting a variable.
Going to go here.
And we're going to set a variable.
Let's actually create one called chart options.
There we go.
And we'll drop down chart options in here.
We'll put that in.
And now we have that captured in a variable, which
allows us, of course, to change those options.
Now, since this particular list is in that key value format
that we talked about in an earlier video,
the easiest way to change it would be to go up here
and to open our library and look for the structured data
library.
Here we go.
And as you remember, structured data
allows us to make changes based on a key.
Then we can change the value.
So that should appear down here.
And that allows us to bring over this block set value.
And we'll bring it over a couple of times here.
And so we'll go over and we'll get our chart option,
because that's what we want to be setting.
And that's the list that we're working with.
Let's bring over another chart option here.
OK, whoops, in the wrong slot.
There we go.
And the first thing that we want to change is title.
Or title doesn't have any information right now.
So we want to change our title to something.
And we'll say CO2 in the atmosphere.
OK, we'll get that as the title.
Then the other thing that we want to change
is the y-axis here.
So there's the x-label and there's the y-label.
So we'll change this one down here to y-label.
And the y-label, we're going to label as parts per million,
PPM.
Oops, there we go, parts per million.
OK, now if I run this, you see that our chart option now
has CO2 in the atmosphere.
And it should have a label, PPM, under the y-label.
And now we can simply apply those as our new options
and call the chart again.
So those options are captured in this variable here.
And if we run this, and we turn off this
so we can see it a little bit better, if we run this,
now the chart has a title and it has a y-axis label.
All right, and if we want to just put everything together,
so it's one nice unit, we can do that.
Bring this down here.
There we go, connect it.
All right, and let's put a block on top of it
when Greenfly clicked.
And we'll click it.
And it ran.
So again, it went out with an RPC to fetch the data set.
And then it went out to find the default options.
We changed some of those options.
And then we called the GNU plot with our new options
and the data.
And we got this visualization.
All right, and we did that in just a handful of blocks.
So that wraps it up.
Thank you very much again for joining me.
And I look forward to seeing you in my next video.
</p>
  

    <h2>3. chat-server</h2>
    <p>Hi, everyone.
Welcome back to Programming for a Networked World.
Today, we're going to continue our exploration of networking
within Netsblocks.
But in our previous examples, we've
used the room with various roles.
This time, we're not going to do that,
because when you're building certain types of applications,
and we'll be building a client server application,
you don't always know the number of users you're going to have.
And you don't want to, as you expand or contract,
have to create new roles or delete roles
as users come and go.
So in this particular application,
we're going to be messaging each other back and forth
with another way of passing information between Netsblocks
programs called a public role ID.
So to begin with, we're just going
to start with that simple exchange of messages
between computers.
And so we'll go over to Brian's side.
And he's going to set up the environment in which we
can receive the message.
And then I'll pass the message to him.
All right, so if we remember back to earlier projects,
like our distributed Hello World,
we have this network category where we have all our message
passing blocks.
So we can use this when I receive message handler
to handle messages that we received over the network.
So if we click on this dropdown, we
can select the built-in message type for now.
You might want to change this later,
but it's a decent starting spot.
And then when we receive the message, let's keep it simple
and just save the message for two seconds.
So we can use this save block and then
drag the contents of the message, which this message
type only has a single field, MSG.
And we can just save this for two seconds.
And then now we just need somebody
to send us a message that we can then display.
So with that, I'll hand it over to Cliff.
OK, so when I want to send a message to Brian,
let me bring this over here.
Now, the problem is I can send a message.
That's fine, and I can say, hello, Brian.
But the problem is we're not sharing a project.
So it's not going to be helpful to say to others in the room
or everyone in a room, because we're actually not in a room
together at this point.
We're just in completely separate Nets Blocks projects.
So how do I actually get the message to you, Brian?
That is a good question.
So in Nets Blocks and under this network category,
we have services and RPCs that we've seen before.
And there's one service in particular
that can be useful here.
It's this public roles service.
This lets us get a public role ID.
So in the past, when we were communicating within a room,
we had multiple roles, and we were just
using the role ID or role name to communicate
with one another.
Now, even if different projects had roles with the same name,
it was no problem to resolve this role name,
because we knew that it was within the room.
But as Cliff mentioned earlier, we're not using a room here.
So we need some sort of absolute or unique address
for the specific project or role that we are
wanting to send a message to.
So if we call this get public role ID,
this will return a public role ID or this kind of unique role
or this unique address for your specific role and project
that we can see here.
So when we click on it, we see this little dialog bubble
pop up that says my role at chat server at Brian.
So it looks a little bit like an email address.
But essentially, if we break it down,
it is your role name at your project name
at your username, which, of course, then is unique.
So to make this a little bit easier for anyone
who might want to connect to this server,
I'll just make a little server address variable, which
I can set when the project starts.
And let's say when the green flag is clicked,
this value will be set.
And now we can see I have this server address little watcher
showing up on the stage, which has the public role
ID or fully qualified kind of unique address
for this specific program.
So the thing is that public role ID is just like an email.
And I remember in the beginning of email back in the 90s
when people were first starting to use email,
the trick was how do you discover someone's email
address?
Because if you don't have their email address,
you can't email them.
And so this is the same problem here.
I actually have to learn that address from Brian.
He has to be able to give it to me in some way.
Otherwise, I can't communicate with him.
So in this case, since he's right next to me,
I'll ask him.
You could have him email your address.
There are other ways to share it.
But you do need to know what his public role
ID is going to be in order to start
the chain of communication.
So I'm going to do the same thing.
I'm going to go over here.
And I'm going to create a variable.
Let's just, I always like to use the script variables.
Let's just do that.
And I'm going to call this one, let's say, well, you know what?
I think Brian is probably thinking,
don't do it this time.
Let's just make a public variable.
Because I may need to use it in various places.
So we're going to call this, let's call it the chat server
ID.
So that's where the chat server is going to be.
And we're going to set that chat server here
to what Brian's public role is.
Now, just tell me, and I'll type it in.
Sure.
So it's my role at chat server.
And there's a space between chat and server.
And I capitalized the C and the S.
It's all very important.
I get it exactly right.
Chat server.
And then at Brian.
Brian, lowercase.
Yep.
OK.
So if I click on that, let's actually just send a message
here.
So I'm going to send that.
And instead of sending it to a room,
I'm going to drop this in here.
And now let's send the message, hello, Brian.
All right, so we didn't see a pop-up on my screen.
And this likely means that there's a typo.
Because, of course, these are sensitive,
just like email addresses, if there's
a typo or things like that.
OK, so let's go over it one more time, then.
So I think we need to change the M to be lowercase.
OK.
Because it is case-sensitive.
Yeah, so it's a lowercase M-Y, capital R-O-L-E.
OK, let's try it again.
All right.
Ah, there it goes.
OK.
There we are.
Awesome.
So now at this point, we've been able to basically recreate
the distributed Hello World project,
but not using the room concept.
Now, again, the room concept, although it's normally
a nice fit, because it makes it a lot easier
to discover addresses.
You don't have to enter or type these addresses in by hand.
You can see who's occupying the role, et cetera.
They're not the best fit for this project,
because we want to have chat clients come and go
as they please.
So we want the size of the chat room to be dynamic.
So at this point, we've been able to, again, recreate this.
But there's one big shortcoming.
So right now, when Cliff sends a message to, unfortunately,
he's the only person in the room.
But he can just lean over and look at my screen,
I guess, to see what everyone's been saying.
But of course, this isn't really ideal,
because you don't want to always have
to be in the same room as the server program.
So we really need the server to not just display the message,
but actually to send it to the people in the conversation
or in the chat room.
So if we're going to do something like that,
when we receive this message, instead
of saying it for two seconds, we would just
want to send it to, in this case, just Cliff.
But we really want to send it to all the people in the room.
So basically, we're forwarding the same message back.
But then the problem is, how does the server
know who's all involved in the room?
So we might want to add a login or register
or some sort of step like that.
I'm going to call it a registration step.
And I'm going to make a new message type for this.
So this would be a step where the person who
wants to join the server sends them a register
message to the server that just has one field,
and that's their address.
And then we will record this as someone
who cares about the conversation or someone who's in the chat room
and to whom we'll send any messages that we receive
from some of the current occupants.
So we can add a new message handler now
for the register message type, which, again,
has a single field called address.
And then we can make a new variable
to say that we have a number of connected clients.
And we just add the current address to the clients.
Now, there are a couple of little things
we might want to keep in mind.
One is that right now, if we look at our stage,
we can see clients is number 0 when we really probably
want it to be a list.
So we should initialize this variable to an empty list
when the program starts.
And we probably don't want to have duplicate entries
in our list of clients.
So we really only want to add them to the list
or add the client to the list if they're not already
in the list.
So just a couple of little edge cases, I guess, to consider.
So if it's not the case that clients already
contains the list or the address name in its list,
then we'll add it.
All right, so now we're able to actually build up
this list of clients.
And then when we receive this message,
we can just send it to our list of clients.
OK, so on my end, then I need to register with the chat server
now.
We've got an additional level of formality
that we didn't have before.
And so what I need to do first is
to recreate that same message type down here.
So let's go to make a message type.
And again, I need to know what that message type is.
And I believe it's register.
So we're going to do that.
And then the field here is going to be, I think it's,
did you call it?
ADDRESS, all lowercase.
OK, address, because that's going to be my public role ID.
OK, and so when we bring that over,
let's just kind of look at sending that message.
So we can drop this down here.
And we'll do a register.
And it should say address.
And then two, we know where it needs to go to.
It needs to go to the chat server.
So let's go over there to get that variable.
Here we go, chat server ID.
And again, to get my address, then I'm
going to go back out to network here.
And I'm going to go to the call block,
as Brian did the same way before.
And I can get my own by looking for public role ID.
There we go.
And dropping it down to get.
And then you can see that that is my particular role ID.
And so I want to send that address to register.
So you probably want to put this into your initial starting
block, so when clicked.
And I guess I probably should have used a different block
to do this.
Could have used this one here.
But let's just have it for now.
Maybe we can just report this.
There we go.
Oh, and I've got, and wait, I really
picked the wrong block here.
So we'll just pull these pieces out, actually.
I think that'll be easier.
So we're going to send a message using this one.
And there we go.
Let's drop this down to register.
There's the address.
And make some space here so we can see it.
Sorry, Ada.
There we go.
And to the chat server.
So that should be good.
Don't need this.
And so now when I first start off,
this will register me with the chat server.
So let's see if that works.
Click.
All right, so on my side, we see an error, expecting a list
but getting a number.
So.
We've run into that one before.
Yeah, so that usually means that somewhere where it, well,
as it says it was expecting a list,
it was not getting a list.
It was getting a number instead.
So if we look at these blocks, because there
aren't too many here, we see that we're
checking to see if clients contains the address.
Well, the address should be the public role ID
that Cliff sent.
And clients, if we look at the value, is zero.
So it looks like, although we wrote the code
to initialize this client's variable to an empty list,
we never ran it.
So let's click the green flag.
And then I'm going to click on this message handler.
So it's, actually, I think it should be fine.
Now, if Cliff runs it again.
One second.
So, one moment.
I seem to see, usually just clicking on those queers,
it's a little bit surprised to see that it's not.
So I'm going to just use a different message handler
quick.
All right, so now Cliff sends this again,
this register message.
Now we can see that clients actually
has his public role ID.
So we see the role name at his project name at his username.
All right, so now let's see what happens
if Cliff sends a message.
All right, so we removed the save block from ours
since we were just relaying the message back.
So now it's not showing up here.
We could add that if we want to maybe debug.
We probably want to get rid of the two seconds portion
here so that we don't slow down the messages
that we can receive.
And now if Cliff sends it again, we
can double check that we are getting the message, in fact.
But we don't yet see it on Cliff's screen
because he doesn't have any message
handler for these messages that have been, again,
kind of passed on back to the clients.
Right, so the message that I'm sending
is still a very simple message type.
Just message and then, hello, Brian.
So we want to make this a little bit more complex.
We want to be able to not only register with the chat server,
but we also want, when we send a message,
to indicate that we were the ones that sent the message.
And you could do this for different reasons.
One is you might not want to always echo back your messages
but just see other people's messages.
In this particular case, we're going
to echo back my message because it's just Brian and me.
But the point is, when you send a message
and you've got a big chat server,
you need to know who sent that message
and then the content of the message.
So for that reason, let's change our message type
from this simple message type.
We're going to create a new message type.
And then you can see here that I can expand the fields.
So we're going to make two fields.
And I'm going to call this, we can call this chat.
I guess we can call it chat.
And then the first field will be ID.
And the second field will be message.
How about that?
Now, the key is, as long as Brian
enters the same message type on his end,
we'll be able to communicate very smoothly.
OK.
So let's bring this new message type over.
Here we go.
And you know what?
This code, by the way, for setting the ID
should go up here when green flag is clicked.
And just to make this a little bit nicer,
let's add some code around this.
So when we start, let's have a sensing here and say,
ask your name, and say, what is your message, and wait.
And then we're going to put the answer here
in our new message type, which is chat.
And the answer will go into the message.
So that's good.
And then we can also capture our public role ID somewhere else.
So we've got that right here.
We probably should create a variable for that.
So let's just do that, too.
So we're going to make a variable
and call it client ID.
And then we're going to drop client ID over here.
And then I'm going to put my ID for the role right there.
OK.
So that sets up stuff in the beginning.
And then we'll register this.
We still need the address, which is we
need my address, which is going to be client ID to register
at the server ID.
OK.
Then here, probably we want something to start this off.
So we say, maybe under control, I guess.
When space key is pressed, that will kick off
sending a message.
Just to clean the screen up.
Well, for now, we leave it like that.
OK.
So when we press the space key, then we'll say,
what is your message?
Then we'll enter the message.
And we're going to send over the client ID here
with the answer to our message.
And we're going to be sending that to the chat server.
So there we go.
That should be enough to send this now,
saying who we are, what our message is,
to the right place.
So let's just try it.
We're going to instantiate everything
so we get the IDs correctly.
And I'm going to stop showing them because they're
a little annoying.
And then let's just press space.
And Ada says, what is your message?
And I'll say, hello, Brian.
Did you get this message?
And let me try to send it.
All right, so now we received the message.
Now, I did make a couple little updates,
updating this chat message handler
to have the ID and message fields,
just like Cliff had created, and to relay that chat message
back.
Right now, we're just saying the contents of the message.
And we might want to include the ID.
So let's try sending that message one more time, Cliff.
Sure.
So I have to actually type it again.
I'll say, hello times 2.
Perfect.
All right, so now we see this message
is displayed, again, in this debug display view,
not really intended to be where all of the chat
clients read the message.
But we do see the ID of the sender and the message.
Now, we might want to use the ID here.
We might want to change that to the username,
using the username block under the sensing category.
It's a little bit up to the user.
But it might be nice to have a more human-readable format
for the address.
So we could actually change this chat message type, right?
Let's go down and let's go to Network.
And we could click on the type.
Let's see, did I get the?
I guess I'd have to just make a new type.
You could do that.
Or you could just actually use the, under the Sensing tab,
pass the username block as your ID.
Think of it like your user ID, as opposed to your address.
Let's do that.
I was thinking we could send all three pieces of information.
But yeah, that would work, too.
So pick your poison.
But for now, let's just do the username, which is my?
All the way at the bottom.
All the way at the bottom, OK.
I've not used this much before.
There we go, username.
OK, and so we would take that client ID out,
put the username in.
And let's see if we can send it below once more.
There we go.
Cool, now we can see that Cliff's username is sent
as the ID with the message.
Now, as Cliff mentioned, there are a lot of different ways
you can design these systems, usually
with a lot of their own affordances and stuff as well.
For example, you could have the register message register
the username, and then just use the client's address
to resolve to the username.
So it can't be spoofed quite as easily and things like that.
But for now, I think we'll keep it simple
and just stick with the design that we have currently.
So now at this point, we've been able to register
different clients, build up this list of these clients,
and send messages to the server.
And the server then relays them back.
But we aren't yet showing these messages on our chat client.
So I think next, Cliff, if you want
to take us through how we can display some of these messages
or at least show them to the actual clients
or on the clients.
So now when I send a message to Brian,
then the chat server is going to record that.
And then it's going to take that list
and send it back to everybody who's registered in the list.
So what I need to do is be able to pick up that message type
coming back from the server.
Now, one thing we can assume is that the server will
be sending messages that are of the chat type.
And if that's the case, then I just need to receive them.
So here, let's go to when I receive.
And I'm going to say chat.
I'll get the ID and the message.
So that we can assume is going to be someone's username as
well as what they are saying.
And now the easiest possible way to do
this is just to kind of duplicate that on our side
and want to be in looks and have Ada say the message.
And so here, we would just say the message.
Well, probably what we want to do is something like this.
We want to do a join block here.
And we want to say that the ID, which is the username,
and then we put something like a colon and a space.
And then we open this up to add another block.
And then we display the message.
And let me just put it up there for five seconds.
And then I should be able to echo those messages back.
So now, when I send a message, it's
still going to go through the chat server.
It's still going to register on Brian's screen.
But then Brian's going to relay it
to everyone who's registered and then send it back.
And then I will pick up that return message and display it.
Let's try that.
So I will press space.
See, here we go, space.
What is your message?
Hello, can you hear me?
And voila, you see that the message came back to me.
So there's a lot more that you could do to build this out
and to display messages on your screen.
Probably you don't want to be picking up
your messages in a say block every time
because in a typical chat log, it's
going to be message after message underneath each other.
Maybe you put them in different colors.
You're in one color.
Everybody else is a different color.
There's lots of things you can do to build this out.
But Brian, I think it's been more than 20 minutes.
I think this is a good introduction to the client
server type of application that you can build with NetBlocks
and also to using those public role IDs as a way
to communicate across NetBlocks instances
without having to use a room or a role.
Yeah, I totally agree.
So thank you, everyone, and look forward
to seeing you in the next video.
All right, bye, everyone.
Bye.
</p>
  

    <h2>4. custom-blocks</h2>
    <p>Hello everyone, and welcome back to our series on programming for a network world.
Today we're going to talk about custom blocks. Have you ever looked through the palette in
NetsBlocks and said, hey, I wish there were a block for that, but it doesn't exist in the palette.
What can you do? Well, the good news is that if you can't find a block, then you can make your
own block. We're going to talk about how to make a custom block and why it's useful to hide the
complexity of your program. By encapsulating some of that complexity in a custom block,
you'll make your programs much more modular and easier to understand.
So, ready to start creating your own blocks? Let's get going.
Okay, today's project is going to be about the weather. What I'd like to do is combine two
network functions in NetsBlocks, two RPCs, one of which is going to tell us our geospatial location,
and the other is going to use that geospatial location to look up the weather and give us an
icon representing the current conditions. So, let's get started with just the basic pieces,
and then we'll talk about how to put them together in a custom block that takes the name of a city
and gives us a weather icon. Okay, so to begin, I'm going to go over here to network,
and I'm going to pull in two call blocks here. The first one I'm going to pull in,
I'm going to change to, let's see if I can find it,
let's call it science and then weather. Okay, and then if we drop it down here,
we'll see that we've got some options here. Let's go to icon, and you see that it requires a latitude
and longitude. Well, we can look that up in various ways, but the easiest way to do that is
just to use another RPC that gives us the latitude and longitude. So, in that case, I'm going to go to
geolocation here, and I'm going to drop this down, and I'm going to say geolocate, and this will take
an address and then return us our latitude and longitude. So, for example, if I put in just the
city of Nashville, Tennessee, and I click on this now, we'll see. Here we go. I get latitude and
longitude in a list of lists or table format. Okay, so if I want to pass this into the latitude
and longitude here, then I need to get that information out of this list of lists so that I
can pass latitude and longitude into the next block here. So, to do that, let's go ahead and create
some variables. We'll go over to variables here, and I'm going to grab some script variables,
and we're going to call one latitude
and the other longitude.
Okay, and now I can set these variables. Here's latitude, and let's set this one to longitude,
but I don't want to call the geolocation twice, so I should probably create another variable
called coordinates that will capture that information after I call it once.
So, I'm going to say coordinates, and now I'll set that coordinates here
to the result of this geolocation call, which is now hidden there. There we go. Let's make this a
little bit smaller so you can see it all. Okay, so I'm going to try now to call the geolocation for
Nashville, Tennessee, set it to coordinates, and then let's pull out the information from
that block. Now, remember, when we index into a list, we're going to want to index to the
particular row and then the item in that list. So, let's do that. We're going to go to
have to have two of these blocks, item 1 and item 2, and so the first one is going to be set to 2,
and then the second one to 1, and let's try that here, of coordinates, because we've already
captured coordinates, and then the same thing here. We'll duplicate that, except this will be
item 2. Now, just to test to see that we're getting the right information, let's just report
the information that we have so far. So, I'm going to go down and grab a report block. I can find it
here. Report, report, report, report. There it is, report, and I'm going to report. Let's just say I'm
going to report the latitude. Let's just make sure we're actually getting the information we want.
So, there's the latitude, and we can test the same thing with the longitude,
and voila. Easy to get those, you know, reversed, and then you'll end up somewhere
off the, you know, an ocean off of the coast of Africa somewhere. So, if that happens, you know
that you've got latitude and longitude reversed. Okay, so now let's drop in this report here,
and we're going to add latitude in the latitude slot, and longitude in the longitude slot,
and if, with any luck, we click on this, we should get an icon representing the current weather
conditions in Nashville, and there you go. It's partly cloudy. Okay, fantastic. So, we've got the
block working, but we don't want to necessarily ask our users to type into this particular slot
every time. It would be nice to have a function that is look up the weather and give us an icon
for a particular city without having to go through the steps of, you know, changing this here and kind
of figuring out what all these calls do. If we made a custom block, it would be very clear. Give the
name of a city, get an icon for the weather back. So, how do we do that? Well, there are two ways to
create a custom block in NetsBlocks. One is that you can click on custom here, and then in this
palette, you'll see make a block, and if you click on that, you get this option to make a block, but you
can also just right click here and click on make a block in the menu that pops up. So, let's go ahead
and click on make a block. Now, you get a lot of options here that you can use, and you can choose
whether it's going to be a command block, a reporter block, a predicate. In this case, we'll make it a
reporter, and we're going to associate it with the network palette, and that's because when you're
thinking about what this block does, you want to associate it with other types of blocks in terms
of its color that do similar things. And so, this is looking up something from the network. It's using
two RPCs, so it seems appropriate to put it under the network tab. So, I'll do that, and then we have
to give it a name. So, the name of this block will say weather icon for location, and then I can say,
is it for all sprites or for this sprite only? We'll just let it be for all sprites. Now, the thing is,
when I create this, you might say, okay, you've created this block. There's this
nice window here that you can use. We can take our script and just put it in here, and now we've got
a custom block that will accomplish the goal of looking up weather for a particular location,
except to say that there's no particular way. Let's see if I can just pull this down a little bit more.
There's no particular way to pass in information to this block. We don't have a slot yet for us to
enter the city. We just have weather icon for location, and if you look at what the block looks
like, which appears here in the palette now, it's just a solid reporter block with no place to enter
information. So, to remedy that, we're going to click on location, and you see that we get another pop-up
here, and it differentiates between title text, which is just that text that appears within the
block, and input name, and an input name provides a slot for you to use to pass information into that
custom block that can be used for computations that are contained within that block. So, if I
click over here, I can see, oh, I've got lots of different options to indicate what type of
information I'd like to come into this block. I can say it could be an object, or a list, or a number.
In this case, I want to use text. So, I'm going to say this block should have a location that's an input
that accepts text as its input, and I'll click that, and you see that it turns it
into what looks like a variable. So, that's going to be the parameter that people pass into this block
that is then used within the block to perform the calculation that the block is supposed to perform.
Okay, so I click on that, and now you see that I have a nice slot for the input, and so if I take
the input, and I say Nashville, will it work? Well, let's try it. There you go, but watch out,
it may not have worked for the reasons that you think. So, we still need here, we've got Nashville,
Tennessee kind of hardwired into our code, so it's always going to report for Nashville, Tennessee.
So, for example, if I looked up Los Angeles, California, it's going to tell me that it's also
partly cloudy there. What we need to do then is take this location block and drop it on top of
where Nashville, Tennessee had been. Now, whenever someone enters a new city, a city other than
Nashville, then the coordinates for that city will be looked up, and it will give the appropriate
weather conditions. So, now let's try it for Los Angeles, and dollars to donuts, Los Angeles is
going to be sunny. Oh, no, no, look at that, it's cloudy. It's cloudy in Los Angeles, but sunny in
Nashville. You never know about the weather. In any case, you can see now that you can use this
to look up weather in any part of the world that you'd like to look up. So, we could say like Berlin,
Germany, and there we go, cloudy and raining in Berlin. So, you've seen in this particular video
how to create a custom block. Custom blocks are wonderful ways to encapsulate information so that
you can use them in larger computations without getting lost in the details of what all the
particular blocks do. So, in this particular case, we composed two RPCs, one to find the
geolocation, the other to pass it to a weather service that provides us an icon that represents
that the weather in that location, and then we made a new block that just allows people to pass
in a city name and get back an icon. So, you can do this with almost anything that you want to do
in NetsBlocks when you want to simplify your computations and build larger programs. Typically,
you'll be doing that by making a lot of custom blocks and then composing those custom blocks
together to make units of computation. So, thanks very much for joining me in this video.
I look forward to seeing you in our next session. Bye-bye.
</p>
  

    <h2>5. distributed-hello-world</h2>
    <p>Hi, everyone.
Welcome back to Programming for a Network World.
Today, we're going to begin our exploration of peer-to-peer
networking in Nest Blocks.
In particular, we're going to learn to pass a message
from one Nest Blocks program to another.
So what we're going to be building today
is something called Distributed Hello World.
It's very traditional when you're
starting off in programming for the first time
to write a Hello World program, but we're
going to do it in a fun way.
I'm going to turn it over to Brian
to help us get started with some of the core concepts
we need to write this program in Nest Blocks.
All right, Brian, take it away.
All right, thank you, Cliff.
So as Cliff mentioned, we're going
to be writing a simple program where we have one application
running on a single computer that sends a message,
like Hello World, to another computer, which
then can display this message.
So I'm going to get started with this sender.
If we look under this Network tab or category
here in the palette, we can see that there's
this Send Message block.
So this will actually allow us to send a message
over the internet to another computer or a program running
on a different device.
So if we select this first dropdown,
there's this Message option, and this is the type of message
that we're sending.
So we're just using the built-in message type
provided by Nest Blocks, which has a single field, MSG.
Now, we can enter Hello World into this field.
Now, we just need to figure out who we
want to send this message to.
So Nest Blocks introduces this concept
of a room, which is composed of multiple roles, which
are basically individual subprojects
within this larger distributed application.
So in this case, we mentioned we wanted
to have one computer sending this message
to another computer.
So say this first computer is running this sender
application, which then sends the message
to this receiver application in this bigger distributed
program.
So we can rename our current role Sender,
and then this will correspond to that first application, which
just sends this Hello World message.
And then we can add another role, the Receiver role,
which corresponds to the application running
on a different computer that receives this message, namely
on Cliff's computer.
So I'll invite Cliff to this role.
OK, and so you see that Brian's message pops up on my screen,
and it invites me to join his program.
Now, one thing to note is when you say yes to this,
you're actually going to be leaving the program that you're
in and joining Brian's.
So what's on my screen now when I accept will disappear.
There we go, and you can see that Ada is gone.
And now I see that my program is called Receiver
at Distributed Hello World.
And that's because if you look in the room,
you see me down here.
I'm inside of the Receiver role at Brian's invitation.
Now, Brian has already created the block that
is going to send the message.
So I need to create a receiver on my side
under this Receiver role to be able to display
the message that he sends.
There is one trick that you have to keep in mind.
So let's just go ahead and start.
We'll go to Network, and I'm going to pull out this When I
Receive block here.
But then I get another pop-up saying,
edits cannot be made on projects by guests.
So this is just a little bit of insurance.
You can invite someone to join one of your projects
and take a role, but not be allowed
to actually edit the code.
So if we want to edit the code together,
then Brian has to give me permission.
So I'm going to request permission from Brian,
see if he accepts.
QUINN CLIFFE requests permissions,
and I see a dialogue pop up on my screen that
asks if I would like to actually make him a collaborator.
So in other words, elevate his permissions from someone
who cannot just play the game to someone
who can actually edit the application
or the underlying code of the Receiver role in this case.
So now that Brian has done that,
I can bring that block back over,
and you see that now it sticks in the coding area.
So all I have to do then is say, when I receive a message,
that's the name of the message, and then I
get the content of the message here.
And so we'll just need to have, oh, well,
we only have a turtle here.
Let's bring Ada back over.
Remember, we lost her in the transition.
So there is Ada.
And so we want Ada to respond now
when this message comes through.
So this is Steve Wozniak traveling back in time,
sending messages to Ada Lovelace,
but let's see if it works.
So I'm going to then say, and what do I say?
I don't say hello.
What I want to say is the content of that message that
came through for two seconds.
And that should be all that it takes.
So let's see if Brian sends that message,
whether I can receive it.
All right, so if I click this Send Message block,
we'll see that nothing shows up on Cliff's screen.
Because if we look back at our code,
we have this Send Message block, but we never
filled out who the recipient was going to be.
So if we select this dropdown, now we
can see Receiver, because Receiver
is the name of the other role in our room,
as well as a couple other options, like Others in Room
and Everyone in Room.
So we can now select Receiver.
And now when we click the block, we
can see that Ada says, hello, world.
So that's a really quick introduction to these concepts.
We're going to be building on them in future videos.
But now you understand the concept of a room,
roles within room, and how to send
messages between those roles.
So thanks, everybody, and we'll see you in our next video.
</p>
  

    <h2>6. errors</h2>
    <p>Hi everyone, welcome back to Programming for a Networked World.
Today we're going to be talking about errors.
Now, if you've seen these videos, you know that I've made my fair share of errors
as I'm working through programs.
And there's a process called debugging
that helps you to identify the source of those errors
and then to correct them.
So today we're going to be covering some of the debugging tools
that are built into NetBlocks and learning how to use them.
So, ready to squash some bugs?
Let's get started.
Okay.
So, today we'll just make a simple program
and I'm going to purposely put some errors into it.
So here we go.
Let me bring over...
Well, let me talk about what this program will do first.
This program is going to divide a number
and then it's going to give you the quotient and the remainder.
So the quotient is the integer part of the division
and then the remainder is whatever is left over from the integer division.
So to do that, let's bring over a program now.
We'll create a program now.
So I'm going to bring over two blocks that we need.
We'll need the mod operator to get the remainder
and we're going to need over here, let's see, floor here.
Okay, and then we're going to divide.
So let's just get these pieces in place.
So if we get 2 divided by, well, let's say actually better, 3 divided by 2,
this should give us the integer part, which is it goes in one time.
And then if we do that same calculation up here,
3 divided by 2 or 3 mod 2, we should get the remainder.
So it's one remainder of one, which is the right answer.
Okay, so let's build this into a custom block.
So I'm going to make a block here and it's going to be an operator
and we'll say, let's call it divide with quotient and remainder.
And we'll need to put in our parameters here, so x and y, and we'll create that.
Then let's turn those into inputs.
Okay, x is an input and y is an input.
There we go.
Now let's build out here our function.
So there we go.
It's got stuck.
That happens.
Sometimes you can just grab another block like this and then drop it over.
So that's a little bit of a bug ourselves that we have in this box,
but maybe it would be fixed by the time you watch this video.
But if it ever happens, that's how you solve it.
Okay, so 3 mod 2, so we don't need the absolute values that we put in here.
We're going to get rid of those because those be the variables that we use.
Okay.
Now let's imagine that we want to return this as a tuple or a list of two items.
So to do that, we're going to make some variable inside here.
So we're going to go to variables and we're going to create a script variable
and we're just going to call this nums.
So there's nums.
Okay.
And let's also create script variables for the quotient and the remainder.
We could do this a little bit more simply,
but I want to make this all explicit so we can sort of look at the steps we need
for debugging.
Okay.
Now let's grab here.
We'll start doing our math.
So first let's do set the quotient to the floor of,
let's get this out of the way, x and y.
Okay.
And then we're going to set, let's see here,
the remainder to mod of x and y.
And then we're going to, under control, report.
There we go.
We're going to report a list of the quotient and remainder.
So we actually need to add this to the list as part of what we're doing here.
So let's do that.
So let's, for example, set,
and we'll just put in here the nums to, well,
let's just add them to the list.
How about that?
So we'll go down to here.
Let's see.
We'll use for this, just this ad.
Okay.
So we're going to add the quotient and we're going to add the remainder.
And what are we adding it to?
Well, this list that we're going to be using, which is nums.
Okay. So that's the quotient.
We don't need this.
We do need the remainder.
And that is also added to nums.
Then we report nums.
So we report the list that contains first the quotient, remainder.
Okay.
Now there are some bugs,
both bugs that will occur at runtime.
That is if a user enters values that we don't expect,
and also bugs that will show up as soon as we run this at all,
because of the way that we're working with lists.
Let's just see what happens.
So, okay.
So we've got that.
We've got this custom block.
Let's bring it out.
Divide.
Okay.
So let's divide three by two again,
and we get an error.
Okay.
Inside error, expecting list, but getting number.
This is very common.
We've seen this before and we know in fact what it is,
but let's pretend that we're a little unsure about why this is causing an error.
So what would we do?
Well,
you've seen me just kind of go through and edit blocks and kind of figure it
out, thinking through the problem, breaking down step by step,
and then building up piece by piece again until it actually works,
which is a typical way of debugging.
But there are some tools that you can use to make that process easier.
The first one I want to show you is the stepping tool here.
So if you say visible stepping and you can click on that,
you can change the rate of stepping.
We'll look at that a little bit.
I'm just going to put it towards the left side because it'll make it a
little slower.
Then I'm going to open this up here so that we can edit this.
And I want, because I want to see what's inside here while we're stepping.
Now,
what stepping allows you to do is to watch the actual sequence of steps
that take place in a way that helps you to see where the error actually
occurs. So if we can click on this now with stepping,
you'll see that it enters into our custom block and it's running through the
various operations.
And you can see each operation as it's taking place.
And then here it breaks down here. Okay.
And this is exactly where the error is. So it's in this block.
So that actually helped us to narrow down where the error was in a really
nice way. And we can say, okay, why did that occur? Well,
I mean, we know the answer.
It's because we haven't set nums to be a list.
We're trying to add nums to something that is not yet a list,
but what if we didn't know exactly what the problem was?
There's another block that you can use that will help us to identify the
error.
And that is a block that we'll find over here under control.
It's very at very much at the bottom pause all.
And it has this like pause label here. Okay.
So let me just stop this. So we've got the visible stepping on,
but I'm going to actually now drop this right into where that error
occurs. So just basically let's say right here. Okay.
This is sometimes called a break point.
Basically it's not stopping our program. It's just pausing our program.
And because it pauses our program,
it allows us to inspect the value of the variables that are you know,
what their state is at the moment.
And then we can see if there's something wrong with one of the variables
that's causing the problem that we're discovering when we try this
operation. So let's give that a shot.
I'm going to turn stepping off and I'm just going to run this like we had
before. So I'll start the program.
And now you see that it looks like it's let's make sure that's right.
Okay. So you should see that it looks like it's paused here. Okay.
And then we can click this button to run it again and then it hits that
error. But when you run it, let's make sure we run it. Okay.
And you see this, that it's paused. It's paused right here.
And now the nice thing is we can click on this and now we get this kind of
set of variables that we can look at.
So these are the variables that are actually being used at this moment in our
program. And if you click on them,
you can display their values in the window here or on the stage,
and you can see what they are. So here we can see.
Now what's wrong here?
Well, we can see that all of these values are integers here.
They're three, two, one numbers is zero quotient is zero.
So let's get the last one here. I guess I stopped it from running.
So let me run it again. Okay. And then the remainder. Okay.
So these are our watchers.
They're showing us the values of the variables at this stage in the program.
Now, if we unpause it, we hit that error and it can help us see, okay,
we know that the error is in this line.
And if we look to see what we're adding quotient to,
you can see that we're adding quotient supposedly to a list,
but we're actually trying to add it to an integer.
So now let's go ahead and fix this.
Let's go over here and under variables,
under variables, we're going to set at the very beginning of the script,
the remainder or no,
sorry nums to a list.
And so let's grab list over here and we'll make it an empty list.
Okay.
And let's unclick these so that we hide them.
We're going to look at them again when we run this.
When we run this.
Okay.
Now let's run it again.
We're going to hit that break point, which we did.
Now we can look at this and we want to look in particular at nums.
And we see now that nums is actually a list rather than an integer.
And so if we run this through,
we see now that nums has the two values that we expected,
and we didn't run into any errors.
That break point allowed us to look at the state of that variable at that
point in time,
and then determine that we had the wrong type of variable and change it
from being an integer to a list.
And that's all the problem.
Now there are other problems in this particular function that we've written,
but they are problems that manifest differently.
They have to do with particular values that might be run through.
So for example,
we could have a divide by zero error and let's just run this through with
maybe don't need the break point anymore.
Now we get the result of infinity and zero.
I'm going to hide this.
There we go.
So it does work,
but we have the values infinity and zero.
Let me just get rid of the break point because we don't need it right now.
And with infinity and zero,
that's because there is no way in mathematics to divide an undefined
operation, a number by zero.
So it gives us infinity.
Now in this particular case,
the way do we want to handle that is probably to check the value of the Y
when it comes in,
but there's other problems here that are maybe even more subtle.
Someone could pass in a letter,
for example,
maybe they thought they were dealing with a variable that contained a
number.
And if you click that,
you're going to get zero and zero.
So it's still not giving you an error.
So we want to check to make sure that the information that we're passing in
our parameters are actually numbers.
The way we would do that is to go back to the way that we've defined these
inputs and to make sure that we require them to be numbers.
That's the easiest way to avoid that type of error.
So let's make sure that there are numbers going in and let's do it here.
All right.
Now let's test that.
And still giving us an A,
but let's try this again.
Now we'll let us type it in because we've defined it to be a number.
So I can't type A.
I have to type a number,
but we still have the problem with zero.
So how do we test?
How do we work with that?
How do we get rid of that to make sure that we don't have this divide by
zero error?
Well,
let's use an if statement then,
and we'll go over here to if,
and then we're just going to test to see this.
We'll put all these blocks in here and we'll say if,
and then we're going to get the,
the value of this.
So we want to say if Y equals zero,
but of course it's not,
if it's equal to,
if it's not equal to,
so we're going to use this Boolean operator to invert that value.
There we go.
So now if Y is not zero,
then do these things.
Otherwise do nothing in this case.
So let's try this.
Now it didn't report because there's no reporter here.
We could probably put in something to report if it's not the case.
It's not the case.
So let's see here.
Maybe we want to say
divide by zero error.
Make sure Y is a,
is not zero.
How about that?
Okay.
So let's try this again.
Now we've got that error,
but if we change it to a one,
then we get the results.
There's no single way to find and address errors.
You have to think about the inputs that you're receiving and the ways that
you're going to defend against those errors,
or if you get errors,
how you're going to show why those errors occurred.
Okay.
Thanks very much.
We'll cover more topics in next blocks in our next video and see you then.
</p>
  

    <h2>7. grader</h2>
    <p>Hello everyone, Brian here. So today I'm going to show you how we can get started doing the assignments for our course.
So first of all, we're going to click the link that we can find in the assignment description, and it'll pull up Netsbox as shown here.
Now this might look like your standard Netsbox setup, except you might notice if you look in the top center, a little bit off to the right, we have this extensions button.
Now this extensions button, which is shown with this little puzzle piece, has an option underneath when we select it for programming for NetworkWorld, in other words, for this course.
Now for now, at the time of this recording anyway, we're just showing one assignment here because this is the example assignment that I'm going to use to just kind of demonstrate how to submit,
but you should see a list of all the assignments that are available for the course.
When you want to start an assignment, first you just select it from this menu, and you'll be prompted about starting the selected assignment.
If you decide to start it, it will open up kind of the starter template or starter project that we'll be working from,
and most of them have a similar structure to this one where we'll have some sort of custom block that we want to open and actually implement.
So in this case, we can see we have this helpful little comment to look inside the block to find the problem.
The way that we can actually get started on implementing this block, or in other words, looking inside the block and finding the problem,
is by right-clicking on the block and selecting edit.
This will open up a block editor where we can just kind of write the code that we want to, or that's necessary to be able to implement the given block.
In this case, the block is just testing if a given number is between some lower and upper bound.
So maybe just as a first pass, I'll just say that nothing is within the range.
Of course, this isn't going to be an answer we expect to do very well,
but it should at least illustrate how we can actually then evaluate our kind of intermediate solution.
If we select the extensions button and go to the programming for a networked world option,
we can now see that this menu is updated, so we can see we have two options.
We can grade our assignment, or we can submit the assignment.
If we select grade the assignment, we'll see that we have a list of tests,
which only has one passing right now.
If I change this from false to true and then rerun the test, now we can see we have four out of five tests passing.
Of course, if this were an assignment that we were actually using in the course,
we probably would like a better solution to get 80%, but for this example, this is sufficient.
If I'm happy with the results that I'm getting, I can either select submit here in this grade assignment window,
or there is also a submit option up here.
I'm going to select it from this window, and when I click submit,
now it'll ask us for our Coursera submission info.
This is where we can enter our Coursera email address,
and then the token that's provided on the Coursera website when we go to submit our assignment.
Once you actually select OK, you should be able to see your results posted on the Coursera website,
and be ready to jump into the next lesson.
Awesome. See you in the next video.
</p>
  

    <h2>8. language-games</h2>
    <p>Hi, welcome back everyone to Programming for a Network World. Today we're going to
wrap up our sessions on textual analysis in Netsbox and we're going to do
something fun. I don't know if you've seen the channel Translation Fails. I
think they changed their name to Twisted Translations, but the idea is that they
take song lyrics and then they run it through Google Translate multiple times
and whatever comes out is what the performer sings. So we're going to make
our own Translation Fails in this particular section and we're going to do
that by combining two RPCs that are built into Netsbox. So are you ready to
mess with song lyrics? Let's get started.
Okay, so here's what we're going to do. We're going to take out from the
Network tab over here the first RPC that we're going to use and if we drop down
we'll see here under music that we have access to Genius. Now for those of you
that don't know Genius, it's a site that gives you information about songs and
song lyrics and you can see here that if you drop down you'll see that you have
Get Artist, Get Song, Get Song Lyrics. Now all of these, if you click on them, will
take an ID. So we need to find out what that ID is first and the way we do that
is to search for songs. So let's just look for the song Don't Stop Believing.
I think that's how you spell it. And we get back actually 10 that have that
match. Let's take a look. Let's actually just go in and take a look at
this a little more carefully by getting the first item. There we go. So item one
and that gives us this chart here. Don't Stop Believing. This one is by The Rock.
Oops, if I can pull this across. The Rock of Ages movie. Okay, but in any case we can
use this version of the song Don't Stop Believing to get our ID which is the
first item there. So let's go over and just get our library for structured data
that we've used before just to make it clear what we're doing. So let's get
structured data, bring it in, go to custom, and let's get the value of that. So we're
gonna drop that in here and we'll get the ID. I can't remember if it's
capitalized or lowercase. Okay, so we did it in caps and there it is. So that gives
us the ID of the song and now if we want to get the lyrics all we need to do is
call it again for the lyrics with that ID. So let's go to network here and go
over and back down to music and to Genius and we're gonna get the song
lyrics and then we're gonna drop this in here and there we go. Don't Stop Believing.
That looks like the song that we're looking for. Okay, and I see this one is
sung by two singers so I think they're indicating who's singing
what part so that's why we're seeing the in brackets there, but that should be
fine. Okay, now what we'd like to do is to take these lyrics and then pass them
into Google Translate, shuffle them between languages so they kind of get
mixed up and then have Ada present the lyrics back to us in English but in
their kind of mixed up form. So in order to do this we need to start building a
program that will allow us to search for the the lyrics that we want, then to
pull out the song lyrics, to tokenize them, to split them into segments by line
and then we're gonna pass them into Google Translate. So the other service
that we are gonna want to use is Google Translate and let's just see how that
works before we get started too far. So we're gonna go to language and then you
see here is translation and translation has a couple things that we're gonna use.
So one is get supported languages. This is just a list of the languages. I think
there are about a hundred, 111 languages that Google Translate supports and
here are their codes. So we'll use those codes. That'll be part of what we use so
we'll kind of leave this out here. But also, and let me just duplicate this, we
also can translate from language to language. So here we can put in a text
and we could say like don't stop believing and we could translate it from
English to say Chinese. Invalid key, please update your as your translation
API key. Well that doesn't sound too good. Let's try this again. Let's just try
FLR.
Okay, there we go. I think that we were just getting an error code because CN for
some reason isn't the code that we want but maybe I'll mention to Brian that we
should improve that error message. Okay, so there we go.
N'arrêtez pas de croire. Don't stop believing in French. All right, so that is
good and actually Chinese probably is ZH but anyway we'll leave it as it is. We
have to look it up here and find out. Yeah, there it is. ZH on T is traditional
Chinese so let's just try that just to see if we can do it. ZH dash on T.
There we go. Something like that. So excuse my Chinese but there you go.
Okay, so we can translate between different languages but the idea is in
going back and forth between these languages we'll lose some of the
exactitude of the translation. Again, this is just a function of machine language
transformation that it doesn't capture all the nuances perfectly especially as
you move between languages and so that should produce some funny lyrics for us
to work with. Okay, so let's now start putting all this together here.
All right, so let's start with just setting up our initial... we'll start with
a win clicked here and this is going to take up a lot of space so we'll see if I
can kind of get everything together and let's also put in some space for
some variables because we're going to need to use them as we go along but the
first one we'll do doesn't need a variable because we'll just do the
sensing that we normally do which is we're going to let Ada ask what song
that we're interested in. What song shall I sing? Okay, and then we'll wait for the
answer and of course the answer comes in this answer. Now here's where we're
going to need our first variable because we want to identify the song that we're
going to be talking about. So let's get the song ID. We'll use that as our first
variable here and the way that we do that, as you know, is we search the songs
and then we get this ID. So we're going to set that variable here to this but
let me move this over here so we've got more space. Okay, so it's not just going
to be don't stop believing. We're going to put in the answer there and we'll see
what it comes out as. Okay, so that'll and we want to set the song ID to that.
Okay, so that will give us the ID and now the next thing we want to get is the
song lyrics. So same process as we had before, song lyrics. We're just going to
set it to a variable here. So let's go over and set song lyrics to whatever
Genius calls with that ID and so we pass in ID here. Okay, and let's just test to
make sure that we're getting the results that we want. Let's go down and report
the results just to make sure we're on the right path here. So we should be
getting the song lyrics back and we click on this and again I'll say don't
stop believing and there the song lyrics come up. So good, we're on the right path
so far. Okay, now the only thing that's left to do is to split these into lines
and I think it's probably easier not to make another variable to do that. We can
just take this operator right here of split and put it into the song lyrics
themselves right there. So let's just drop this in here and then we're going
to split what comes back by line. So that should give us the various verses of the
song. We can test that again just to make sure it's working. I'm gonna have to
pick a shorter song. A song with a shorter title I should say. There we go.
Okay, it's working. We do have some like spaces that we need to fill in so we'll
these we should remove from our list so we'll have to think about how to do that
in a moment. But basically we've got everything that we want so the only
thing that we might want to do is capture the title of the song. So we
could also just do that here by putting the song title. Let's do this in
lowercase like we've done. Song title. All right and again with a variable here.
Now if you remember when we when we called this to get the information from
geniuses that we can actually just duplicate this probably. All right this
is item one. When we call this and we say like anything I'll try I am Walrus
this time we get the title it's the second item here. So what we'll want to
do then is we probably shouldn't call twice it would be better not to do that
but I think for sake of expediency I'm going to do that. So I'm just gonna
duplicate this here and put this in here and then we're gonna get item two of
that. I'm sorry we want item one that's still the same but what we want to
change here is title and I think it's lowercase. Let's just see if we're
getting the title now. So drop this back in here. Let me pull this out of the way.
Okay okay so let's pull this out of the way and just see if we're getting the
song title coming back. Should just actually mimic what we're putting in.
Yeah okay so that's good it's working. All right so we've got our pieces of
information that we need from Genius. Now we need to pass those into Google
Translate to do the mix of translations. All right so let's throw this out of the
way and we'll keep these pieces here but we don't need this any longer and we
don't need this any longer. All right the first thing that we want to do is to
create a list of the translations the languages that are supported by Google
Translate or Azure Translate in this particular case I think we may be using.
So I apologize for Google we may be using Azure. And so here we go let's then
fill this in and we'll say languages. Okay I'm gonna put this over to the side.
Okay so the languages that are supported we'll just assign to that variable there.
So let's do that and let's call and get those languages that are supported.
Okay so we're gonna set languages to call translation get supported languages.
So that's gonna give us that list that we saw and then we can work with that
list to pick languages that we want to translate into. Now this is this is the
tricky part we're gonna use this under the variables tab we're gonna use this
for each and just to make it clear what we're talking about we're gonna talk
about we're gonna work on each verse at a time gonna translate that and so let's
get the song lyrics. So for each verse in the song lyrics that's basically what
we're gonna iterate through we're gonna translate them. So let's now do a little
setup so the starting language that we're going to start with is going to be
English so and then the starting translation that we're going to start
with is is the verse. So let's do a couple variables inside here oops oops
there we go all right script variables we'll put it right here and so we're
gonna start with let's say the the source that's gonna be the the source
language and that will be English to start with and then the destination
language that's gonna be a random destination to any language that we
choose from that list and then we want our translated text so let's add that
whoops I didn't mean to run it there we go let's stop it so we'll say
translation okay so that's the three variables that we're going to need for
this now to start working on this let's begin by setting the translation to the
verse that we're going to use so that's what's coming in that's the original
untranslated version so that's going to be the what we start with as our
translation and then we're gonna have to send it for translation now remember
when I said that there are some lines that don't contain anything so one way
we can say it's just if there is a verse if there's any verse at all then we'll
do this if there's not we'll skip to the next line so that eliminates those gaps
in the verses the the places that came back as just empty spaces okay now let's
begin by setting the source because we're working with English songs to set
the source to English all right so the source will be to begin with is going to
be EN all right let's move this over here we're running out of space maybe if
I can pull this down a little bit create more space for us there we go
okay that's clearing up our scripting area a little bit okay so if there's a
verse we're gonna say okay the starting language is going to be English and now
we want to set the destination so let's do another variable here oops under
variables we're going to set the destination to now what do we set the
destination to well here's where we want to pick a random item so in order to get
a random item let's just look at this Google Translate again I'm going to
duplicate this and let's drop this down to that get supported languages so in
order to get a random item we will just get a number from one to now we could
just put in 111 but that's that's hard coding data and you know as your might
add another language so we're gonna leave our options open so we'll say to
the length of this so that's going to be some number that's there actually I
shouldn't pick one two I want a random number so let's go over here so I think
random might be over here pick random okay that's what I wanted so let's do
pick random from one to link that so that should just gives a random number
every time good up to the length of the list of translations that are supported
by Azure okay and now we just want to pick one of those from this language
translation so let's let's call that here and we're just going to use the
item of put this in as our list put this in as the number that we want so that
will get a random one each time let's just see how it works so now we see we
got AM which is a language code for something I don't know OTQ YUE LZH okay
all these languages I'm not familiar with but what we do see is that we want
item one of it that's the code that we want so we're gonna put item one around
this and that should just come out with the code with nothing else okay so we're
seeing the codes there okay that's perfect now we don't need to call out
twice because we're actually going to use this variable languages that we've
set up here so let's pull this whoops that's actually what the length of want
to pull this out and we want to put in length of languages and then here we
want to pull this out and we just want to put in languages that way we're not
calling back and forth we're just using the call that we made one time up here
and so then we need to set the destination language to that random
language okay so that's good now we've got our source language and we've got
our destination language so that's awesome all we need to do now is to set
our translation so if we've got this we will set those and then let's let's do
the translation here under variables and set our translation did it go in let's
there we go and set our translation to translate now what we want to translate
is the verse here from the source
to the destination now I think we're gonna get rid of verse and I'll talk
about why in a moment but we're just gonna start with this translation which
is actually already been set it's the same as the verse when it starts okay so
we've got that ready now let's just see if we can say the translation
all right we're gonna put it in here whoop there we go it's not gonna be
hello it's going to be the translation and we'll just have it appear on screen
for a moment now let me pull this over and we'll see if it works okay which
song so they saying don't stop believing oh yeah we haven't translated it back to
English so we're translating it into random languages that is cool each time
a different verse into a different language but we need to remember that
after we do that we need to set it back to its its English form okay so let's
then duplicate this
and put this right here we don't need this twice okay so we're gonna set
translation here now here's the trick this source is English but if the second
time around it's not so we're gonna need to switch those variables and let's see
if we can do this here with variable to set it okay so we're gonna set the
source now to the destination so basically swap those variables and then
the destination here is going to be English so that's where we end so we
know that that's that's hard-coded so source is first English and then we set
the destination to a random language and we translate from the source which is
English to that random language then we're translating back because we have
to indicate what language it was so now we're translating from the source which
is the random language that we chose back in English and then saying the
translation so let's see if that works
don't stop believing don't stop believing
okay so it's working but if you really want to make it crazy you need to move
between languages more than once so let's add in a repeat block and the only
trick here is just getting the repeat block into the right place so here I go
I'm gonna grab repeat I think we'll just do it three times so I'm gonna drop it
in right there and this part here should work
let's see if we go like that okay so we're going to set the destination
gonna call the translation I'm gonna switch the source to the destination and
then we're gonna repeat not ten times which would be a lot of calls but three
times and then we'll come back and set it to English for our final presentation
of what Ada would be singing if we could hear her sing all right that should
produce the wanted effect of really scrambling the lyrics let's try it out
all right here we go drumroll should we do I'm the walrus this time if I can
spell it I am the walrus okay walrus song
he's the one you are and we're all together it's close enough look how they
run like pigs out of the guns see how they fly I'm crying cry surah to sitting
on the ledge I'm waiting for the pain to come
company shirt bloodied class man you're an ugly boy and you let your face grow
for a long time choir I'm an egg an egg I'm a walrus goo goo good you well no
one really knows what that means anyway so that's hard to translate all right so
we'll wrap it up there this is as you see just a fun exercise showing you
again how you can combine two RPCs to create a fun effect if you like extra
credit I would encourage you to make a video in which you use this tool to
create those lyrics and then sing it yourself I'd love to see it so thanks
very much for watching and we will see you in our next unit
</p>
  

    <h2>9. language-id-part-one</h2>
    <p>Hi, everyone.
Welcome back to Programming for a Networked World.
Today, we're going to continue our exploration
of textual analysis in NetSplox.
In particular, what we're going to do today
is to explore frequency analysis.
Frequency analysis looks at the appearance
of letters in documents and uses that
to tell certain things about the documents
that you wouldn't otherwise know.
It's often a technique used in cryptography to break codes.
But today, we're going to be using it
for a different purpose.
We're going to try to see if we can identify
the language of a document without looking
at the document itself, just by looking at the frequency
at which certain letters appear.
All right, are you ready to explore
the world of international literature in NetSplox?
Let's get started.
So to do our program, we're going to have
to draw on several sources today.
One is we're going to need a list of the frequency of letters
in various languages.
And then we're going to need to connect to a source that
will allow us to bring down documents.
And then we'll have to turn those documents into letters,
count how frequently they appear,
and then compare the two sources together,
the list of how letters appear in languages in general,
and then how they appear in this document in particular.
And that will tell us, hopefully,
what language the document was written in.
So let's get started by just pulling in our data sources.
So I will go over here.
And I've got up on GitHub a list of data
showing the frequency in which letters
appear in various languages.
So you can see in the English language,
the letter A appears 8% of the time, 7% in French, 6%
in German, 11% in Spanish, and so on and so forth.
So that will tell us, in general,
what we should expect to see when
we're looking at a document in terms of how frequently
a letter appears or ought to appear in that document.
Of course, it all depends on the length of the document
and what the document's about.
If you have Winnie the Pooh, for example,
you might have a lot more W's and a lot more O's,
just because Winnie and Pooh are mentioned a lot.
So in this particular case, we wouldn't
know if it would match exactly with our expectation of W,
which appears only 2% of the time in English.
But it might appear more in that particular volume.
So the actual percentages will vary
depending on what volume we choose to analyze.
But we can expect that, roughly, they
will correspond to these percentages that we see here.
So let's get these first into Nets Blocks.
So the way to do that, we're going to look at this.
We'll turn it into the raw view, which just makes a nice CSV.
And we'll grab that URL.
And I'm going to go over to Nets Blocks.
And I'm going to go to the sensing block.
And let me bring over this URL here.
And then I'm going to drop that particular link in here.
And you see that we get back a text block showing that link.
So that's good so far.
But it's not a CSV.
But fortunately, there is a tool for that here
under Operators, Split.
And we can put this up here.
And I can drop the URL inside it.
There we go.
And the amazing thing about Split,
I'll just move Ada over a little bit,
because it's a really long URL.
Oh, let me zoom in a little bit better
so we can see this all.
Well, I guess I'll leave it at this zoom.
So you can see that it's a CSV here.
And we have a chance to split by something.
Let's see.
But I'm not seeing the by, which I keep moving.
Let's just pull it out here.
Well, there we go.
So here's the by.
I'm going to set it first.
You can set it to split by CSV, comma separated values.
So let me drop that in here again.
Now we've got the by CSV at the bottom.
That's good.
If I click on that, you see now that we
have this list of list formats.
So that was actually pretty easy to bring
this data into Nets Blocks.
OK.
So then our next step is we hit Escape here and get back out.
There we go.
Our next step, then, is to assign that to a variable.
Let's make a variable.
And let's call it letter frequency.
So I will go under Variables here, make a variable,
call it letter frequencies.
OK.
And we don't need to see it on the stage.
Let's bring it over.
And we'll set letter frequencies to this.
All right, so now we've got our letter frequencies.
So that's great.
The next step we want to do is to think
about where we'll actually get the volume that
we'll be analyzing.
So in this case, there's a site called Project Gutenberg.
There we go.
And if you see Project Gutenberg here,
we can just look at popular books.
There are all kinds of books that are freely available.
And so it'd be great to analyze one of these.
Now, there's fortunately a built-in RPC to Project
Gutenberg inside of Netsblocks.
So let's go over to Netsblocks again.
And let's look at our list of RPCs.
And I'll bring this over here.
And you can see here that under Text, I believe,
let's see our Language, we've got Project Gutenberg.
And so let's drop down.
And there's several things we can do here.
We can search, we can get info, and we can get text.
So we might want to search for a book.
Let's do a title.
And let's say, I said Winnie the Pooh.
So let's search for that, see if they're there.
There are a couple books now that have Winnie in the title.
We don't know what they are until we actually look at them.
So let's grab 34551.
And I can go to this now to get the info of 34551
and call that.
And this is which Winnie?
Don't know much about that, but we
can go with that one for now.
OK.
So that's how we get information about a book.
And if we actually want to get the book itself,
let me just duplicate this.
We just switch this now to get the text.
I'll have to enter that again, 34551.
And we click on that, and there's the full text.
OK, so that's great.
Now comes the interesting part.
How do we look at the frequency of the letters
inside of Project Gutenberg?
So this is where we're going to need to think about how
to bring this text into Nextbox.
Then we're going to split it apart by letter.
Then we're going to look at the letter frequencies
and then we'll report back that information
in the form of a list.
OK, so we'll need to make a block for that.
I think it's better to do that inside of a block.
So we're going to make a block.
We'll have it be a reporter.
We're going to call it, let's see, letter frequency.
OK, and let's make it an operator.
There we go.
And we'll do that.
OK, we'll add here an input called text.
And let's make that input text type.
Say OK.
There we go.
So now we can work with this.
And the question is, how do we build this block?
Well, let's assume that what's passed in
is the text of the document.
So we'll start from there.
And the first thing that we want to do
is get that document and split it by its letters.
So let's make another variable.
We'll start using some script variables here.
So let's go over to variables and let's
get the script variable.
And let's call this one just letters, OK?
So now let's set letters to.
Now here's what we need to think about.
We want to set letters to this document
but split into its individual letters.
So we're going to go back to that split operator
we used before and bring it over.
Here we go.
And this time we're going to split the text,
but not by CSV, but by letter.
OK, so now we should have all of the letters in the document.
But our goal is to get the frequency in which
those letters appear.
So let's make another variable for this called frequencies,
or just frequency.
There we go.
And that's supposed to be a list.
So let's start off by just making sure
that we set it as a list because, as we know,
that's a common source of error not setting
the variable correctly.
So let's say frequency here.
And we're just going to set it to an empty list for now.
So that'll be what we want to fill up with our analysis here.
So then the next part of what we need to do
is to think about how to start calculating those frequencies.
Well, we want a list of A to Z. So we
need to look for each letter A to Z, which
means that we need to say, let's loop from A until the letter
Z and then look for their occurrence.
In order to make a loop like that,
we need to get a list of letters from A to Z.
So we could just list it out, just put a list together
and just start filling in like A and then B and then C.
I don't really want to do that because most programmers
are lazy and they like to find easier, shorter ways
to do things.
So let's do a little trick to do this.
So we're going to make another variable here called letters.
And then I will bring over the set block.
And we'll set letters.
But what will we set it to?
Now, here's the trick.
We can use Unicode for this purpose.
And so I will bring over a map block.
And I'm going to go to this operator here called,
let's see, from, is it here?
Yeah, OK, so we want Unicode of as a number.
So we're going to map these numbers.
We're going to map a list of numbers.
And we're going to turn each of those numbers, which
are the Unicode equivalent of our alphanumeric characters
into the character itself and build a list that way.
So we just need over what.
And here's where we would go to a list.
And we'll just create numbers from, not from 1 to 10,
but from the portion of Unicode in which these lowercase
letters appear.
That happens to be just off the top of my head.
No, I've got it written down, 97 to 122.
So that now will take 97 to 122 and then convert those
from numbers into the alphanumeric equivalent
according to the Unicode chart.
And that means that we'll just develop our letters
without actually having to write it all out,
which saves us time and is a more fun way to do it anyway.
So then the next thing that we need to do is,
if I can get this to pull down a little bit more.
There we go.
We want to do a for each loop.
So we're going to take each letter,
and we're going to iterate over it.
So let's go over here to variables.
We're already there.
Grab this for each.
Drop it in here.
We're going to change this now to letter.
And for each letter in our list of letters,
so that's going to be from A to Z. So it'll be A, and then B,
and then C, and then D, and so forth.
We'll do something.
So how do we do this?
Well, we want to look for every occurrence of the letter
in the particular document.
And these are really big documents,
so these are really long lists of letters.
So we'll take a kind of approach that
shrinks our list each time so that at each successive pass,
our list is smaller.
And we're doing that for performance reasons.
So the way that we'll calculate it is,
we'll take the starting length of the list,
and then we'll subtract all the letters
that we're looking for in that list, so like all the A's.
And then we'll see what the ending length of that list is.
And based on the difference between the starting
length and the ending length, we'll
know how many times a particular letter appeared in that list.
But at the same time, we'll also be shrinking our list
so that we'll be making the list smaller.
So to do that, we need to set up some more script variables.
But now, inside of this particular loop here,
so we're going to do this.
We'll say starting length, and then we'll
make another one that's ending length.
And so with starting length and ending length,
we'll have the information we need
to do that kind of calculation.
So we'll begin by setting the starting length here
under variables, set the starting length.
And what will we set it to?
We'll set it to the, oh, actually, this probably,
we've got letters in there twice.
So that's a mistake.
Let's change this one here to document.
And we'll just change this one here down to document.
There, OK, that's clear.
So we're going to start this with setting
the length to the document, the whole document, all
the letters.
And then we'll use this higher order function here
called keep.
And what keep does is just allows
us to keep the information in the list that we want
and get rid of everything else.
So let's bring this over, keep.
And we'll set the document.
So this is going to mutate the list to what we actually keep.
So here we'll go set, drop it in here.
We're going to set document there to what we keep.
And so this requires an input, and that input
is going to be document.
And then we'll set the document to what we actually keep.
And then what we keep, well, you might
think we're going to keep the letter.
But actually, we want to keep every letter except
for the letter that we're looking for.
So let's bring over a not here, put it in here.
And then the question is, what are we not keeping?
We're not keeping the letter in the document
that this is equal to.
So we'll leave this slot open, and we'll
say, if this letter is equal to that letter,
if it's not equal to that letter now,
then we'll keep that item in the list.
But anything that is equal to that letter
will be filtered out.
And so now, at the end of this, we
need to take our length of the list of letters
that's in document after our second pass.
So that's the ending length.
And copy that.
Let's see, we'll just bring it down from here.
OK?
And now, we need to just have some kind of way
to collect this.
So I think we've got our frequency list here,
and we'll add that information to the frequency list.
So let's go to our list here of add.
OK?
Drop that in here.
And what we want to add now is the difference
between the starting length and the ending length.
OK.
And we're going to add that to frequency.
And then, at the end of all this,
we simply just want to report the frequency.
So that's what comes out of this particular block,
this function.
So let's go to Control.
And we'll report this one down here.
OK.
And I'm going to report frequency.
I can drag it down there.
There we go.
OK.
That should be what we want.
Now, here's the test of it.
Let's see if it actually works.
We'll bring it over.
Here's our letter of frequency.
Let's just do it with a simple, like, this is a test.
We won't do anything complicated there.
All right, so this is not quite what I expected.
Let's see what's going on here.
All right.
So we're splitting the document by the letter.
We're turning frequencies to a list.
We're mapping Unicode over numbers 97 to 92.
For each letter and letter, we're
getting the start and ending count.
Oh, oh, oh.
Here's our mistake right here.
We need to change this to length of,
because we're counting the number of letters
in this document, not actually adding the document itself.
So let's do that.
There we go.
And then we can do the same thing if we just duplicate.
Oops.
Duplicate that one down here.
There we go.
All right.
Let's try it again.
OK.
Yeah.
So now it's working.
We've got a list that goes from 1 to 26.
So each one of those is from A to Z.
And then here is the count of those numbers
per their frequency in the document.
So let's try to run this over a real text.
So here we go.
Let's bring this text over.
We're going to get the whole text there.
And we'll count the letter frequencies.
So it'll go out to Project Gutenberg,
get that particular text.
And then we'll do this count and see what it gives us.
Takes us a little while because it's
doing quite a few operations.
So we'll see.
There we go.
OK.
So quite a few As.
It's a big book.
So here are distributions of the letters
in this particular document.
Now, what we want to do then is to think
about the percentages of these letters as they appear.
Because that's how we're going to be able to compare them,
not just based on the actual absolute numbers,
but the percentages in which they appear in that document.
So let's assign these two variables.
So up here, we'll go to Set.
And I'm going to just put on some script variables here.
Let's see.
So we'll set book here.
And then we'll set the book down here
to the actual Project Gutenberg book that we grabbed.
And then we will set the, let's make another variable here.
That would be, say, book frequency, book letter
frequency.
And we'll set book letter frequency to this.
We'll drop the book into here.
OK, so far, so good.
And now we want to set the percentage of appearance
of letters, of letter frequency, just
to differentiate between the absolute frequency
and the percentage in which those letters appear.
So we'll do this.
And now let's take this letter frequency.
OK, how do we convert that?
So let's get the absolute count, so count of letters.
And we can get the absolute count,
because we've already converted this.
This is the text here.
So we just need to convert those into letters themselves.
So we've done that inside of our function.
So it's maybe a little redundant.
But let's just do it here again.
So we'll set count of letters.
And we'll do the length.
Let's see here.
The length of the split into letters
of the book split by letter.
OK, so that should give us that amount.
And now, percentage of the letter frequencies.
This is where we need to use a map,
because we want to take that number of the absolute count.
And for each one of our counts, we
want to divide it by that number.
So let's do this.
Let's go to letter sum.
And we're going to map here.
Let's take a look here.
We're going to map.
And what we're going to map is each one of those entries
divided by the count of letters.
And what we're mapping over is our book letter frequency.
But now, as I told you, we actually
want to then turn these into percentages that
are out of 100.
So in order to do that, we're going to multiply here
the operator discount by 100.
Let's put it in here.
And that will make it comparable with our other list.
OK, so let's try that.
And let's see how we go here.
Let's report something here.
So let's report under Control.
We'll report percentage letter frequency.
Let's do that.
OK, this may take a while to run, but let's see how it goes.
So as you see here, we're going out and calculating
this letter frequency.
We're not using that yet, but it's still
part of our stack that we're building up.
Then we're getting the particular book.
We are getting the letter frequencies for that book.
And now we get the percentages.
So here, you can see that here are the total percentages.
And if you added these up, you would get to 100.
OK, so now we have what we need to compare.
We actually now have two lists.
We've got a list of the actual percentages
of these letters' appearances in a book.
And then beyond that, we have the list
of what we expect to see out of the entire English language
for the frequency of letters as they appear
over all of English literature.
And we want to compare the two.
And by comparing them, we'll see if this book
was written in English.
This one, I think we probably already
know is written in English.
But we'll try some others that aren't.
So I'm going to pause here for today.
I think that's enough for one video.
And what we'll do in our next video
is we'll learn how to plot these results,
compare them with each other, and then
be able to determine using those plots whether a book is
written in a particular language.
So we'll come back to that next week.
But thank you very much for joining me this week
and talk to you again soon.
</p>
  

    <h2>10. language-id-part-two</h2>
    <p>Hi, everyone.
Welcome back to Programming for a Networked World.
Today, we're continuing our exploration
of textual analysis by doing frequency analysis
over letters in particular texts.
So this is part two of a video.
If you haven't seen part one, you
should go back and view that first.
Today, we're just going to be continuing
with our exploration of the frequency patterns
in various texts and comparing them to the overall frequency
of letters in particular languages.
And our goal today is to visualize the results.
So ready to graph our frequencies?
Let's get started.
Here's where we were.
This is where we left off last time.
And if you remember, we are gathering the letter frequencies
for various languages here.
And then we're getting a particular text
from Project Gutenberg.
We are splitting that text up according
to the frequency in the book, getting the letters
and seeing how frequently they appear in the book.
And then we're getting the count of those letters,
and then the percentage of those letters,
and then assigning this to that percentage of letters
frequency variable.
So our goal, as I said, is to be able to graph our results.
And we need to do two things.
We want to graph the results that we're getting here
from this particular book.
And we also want to graph the results that
serve our baseline comparison from whatever language
we think the book may be written in.
So let's actually start with the baseline comparison.
So I'm going to go over here to we
have a variable that's over here, letter frequencies.
Let's just take a look at this.
When I click on this, I get that big chart.
And so we need to get rid of that chart.
And the way to do that is just we
want to pull out a particular language.
So let's grab, let's see here, a couple of blocks to do that.
We're going to need this item of.
And we're also going to need the higher order block here,
map over.
And so let's just take this here and put that there.
We want item four of the list.
And let's see how this works.
There.
So this pulls out, you can see here, German.
And then here are the frequencies for A, B, C, D, E,
and so forth in German.
And if we switch this to number five, we've got Spanish now.
So each time we switch this number,
and I think probably two is going to be English.
There we go.
So each time we use this, we get a different language
and its frequency of letters in that language just overall.
Now, you notice that we do also get the language name.
And we don't actually want that in our results
because we need to just work with the numbers themselves.
So we're going to use this convenient block called
allbutfirst.
It's a pretty common operation to divide lists
into head or tail of the list.
And the head is the first item in the list,
and the tail is the rest of the items.
So this just gets the tail of the list.
And if we click on that, then you can see that we have a list
here that goes from 1 to 26.
So that's our letter frequency for English.
So that's fantastic.
Now we just need to assign that to a variable.
So let's go over here.
We'll just make a script variable,
and we'll say baseline letter frequency.
And there we go.
And let's just put this.
We need to put it after we set the letter frequency.
So let's put a block in to set that.
Right here is probably the best place to do it.
Say baseline letter frequency.
And then we'll drop this into it.
So now we should have the frequencies
from the actual text that we're looking at as well
as our baseline frequencies, and we just need to graph them.
Now, to remember, we've done this before.
I'm going to go over to network.
We're going to see if I get more space here.
And we want to get this variable here or this block here.
And let's drop down to graph.
Let's see here.
There's a chart service, I think, is what it's called.
There we go.
And the chart service, if you recall,
has a set of default options already built in.
We're going to want to tweak these options,
but let's go with them for now.
So that'll just be our starting point.
And then let's duplicate this.
And there we go, a little bit more space.
Let's drop this down to just draw.
So draw takes the lines that we want to graph here
as well as the options.
So we can just drop the options in there for now.
And we have two things that we want to chart.
We want to chart the percentage of letters frequency
as well as the baseline letter frequency.
So to do that, we're going to pass in a list
with both of those there.
So we'll bring this over here.
We're going to open up another slot.
And let's pull them in.
So baseline letter frequency, we'll pull in first.
And then the percentage of letter frequency,
we'll in second.
And then we're going to report this.
Well, actually, don't want to report it, right?
We just want to visualize it on the stage.
So I'm going to throw this off to the side.
And let's pull down Looks here, switch to Costume,
because we want to actually switch to the charting service.
And Ada will disappear.
And our chart should appear if it worked correctly.
Just to make this work more smoothly,
we'll put a when clicked on top here to kick it all off.
There we go.
All right, so it's getting more complicated.
Let's see if it works.
All right, going out and getting the book,
getting the frequencies of the letters in the book.
And if it all works well, we should see a chart appear
fairly soon.
Still running, so not yet.
There we go.
So actually, that did pretty well.
The only thing is we don't really
know what this chart is showing us.
We do know because we know the context that this
is the percentage of the letters' appearance
in the alphabet and also in the text that we're looking at.
And then these are the letters themselves.
So first letter is A, all the way to Z.
And you can see here that actually this maps pretty well.
So it's a good chance.
And in fact, we've seen this before.
So it's a good chance.
And in fact, we haven't looked at the book.
But it's a good chance that this book is in English
because these values match pretty well.
So let's go ahead and put together
some of the items that would make this chart
a little bit more readable.
And again, we have a video on how
to do this earlier in our series.
So if you want to go back and refer to that
as I move a little bit more quickly here, please do so.
All right, so let's pull the, let's
pull in a library that we want to use here.
So I'm going to go to Libraries.
And the library I want to do is I
want to do Structured Data here.
So the reason I typed in Set is because it
has this block Set Value.
And I want to be able to use that because it'll
make our work a lot easier.
So I'm going to pull that in.
And it's under Custom now.
And so you can see here that I can now start
setting values by key here.
Now, we'll need to make yet another variable here
called Chart Options.
And then what we'll do is we'll go back to Variables here.
And we're going to Set Chart Options.
Let's see, it's a lot of stuff going on now.
But I think probably we'll just do it right here,
just because that's where we're starting to work with the chart.
So we're going to Set Chart Options.
And here, let's get this out of the way,
we'll set it to our baseline options.
Now, we're going to adjust those.
But we need to pass in this new chart options here into Options.
And so our goal now is to make the adjustments we
need in between this Set block and the Switch to Costume block.
So first thing let's do is set a title.
And let's actually, I'm going to duplicate this.
Maybe the way to do this is I'm just
going to duplicate this block right here.
I'm going to bring it down, because that'll
help us to see what the options are that we want to work with
and how to describe their keys.
So you see Title is right here.
So we want to set the title.
And we'll say, just say Set Title of,
and then let's bring the Chart Options block here.
There we go.
So set the title of Chart Options to,
and then we'll just say, Book versus Language.
OK.
And then let's duplicate this again.
So maybe I should have kept this a little bit separate,
easier to duplicate.
Now I've got pieces that I don't want, but that's all right.
We can get rid of them.
And I'm going to duplicate it again,
because we're going to want to set the x and y-axes.
OK, so let's do that.
And again, here's this Chart Options
so we can sort of see how to call them.
All right.
So we've got the x label and the y label.
So the x label here is going to be Letter of Alphabet.
And then the y label is Percentage of Letter Frequency.
All right.
So let's drop that in here.
And now the only other thing we could do
is we could also put in individual labels
to indicate what language we're dealing with,
as well as what book we're looking at.
We don't have that information yet, but we could get it.
So for example, we could make another variable saying,
Book Title.
Let's just do that.
So Book Title.
OK, and then we might want to use this Language Name.
Or I mean, I guess we could just call it Language.
OK.
So now we've got Book Title and Language.
How do we actually assign them to things?
Well, Book Title, we'll drop in here.
And we're going to duplicate this call, Project Gutenberg
block, drop it in here.
But instead of Get Text, we're going to get Info about it.
And then we'll type in the same ID.
We should probably abstract the ID out
and make it something separate here.
So that's on our to-do list if we
want to make this a little bit fancier.
But let's just actually call out to this
just to see how this works.
So this gives us, we're working with Which Winnie.
And we actually need the title here.
There's a title and a short title.
But we'll just grab the title.
So that is Item 2.
And that's going to give us the title.
But it's also going to give us the key for the title, which
we don't want.
So we're going to want Item 2 of Item 2.
There we go.
Let's see how that works.
OK, Which Winnie, the Story of a King's Daughter.
I wonder if we do 3 if we get any.
Oops, this one needs to be 3.
That is better.
Oh, that gets the author.
OK.
Maybe that's a better way to do it.
OK, so let's do that.
So we don't want to set book.
This is the wrong variable.
We want to set, got this down.
OK, here we go.
Let's go to book title.
OK, so now we have the book title.
So now we need to get the name of the language
that we're going to be using.
And you remember, we did that up here
when we did all of it first.
So I think what we could do then is just do the opposite.
So we could duplicate this.
And let's make another block under here.
And let's just, it should be a variable here.
OK, let's set this instead of all but first,
we're going to set this to language title.
And this stays.
I can keep this stuff variable and easy to move around.
OK, so that stays.
But we just want item 1.
So in this case, we just want the head
because that will give us the title.
And that will give us the language.
Again, we should probably extract this information out
so we're grabbing the same language
so there won't be any confusion about that.
But now we set the language, and then we set the book title.
So we can go down here.
And let me just pull this down and see
if I can duplicate this block.
There we go.
And we'll reconnect these things.
OK, so now what we want to set are the labels up here.
Let's see that it requires a list, which is good
because it's a list that are the labels that
are what correspond to the two lists that we sent in
that is charted.
OK, so let's grab list here.
And the first one I passed in was the baseline.
So that's going to be the language.
Let's grab that right here.
So I'll make my way down.
There we go.
And then the other one that we want is the book title.
So let's add that down here.
All right.
So that's good.
Now this just needs to be, I think,
what we say was labels, right?
Labels.
OK, so let's get labels in.
Now we're passing all this information in.
Let's get this out of the way so we're not confused by it.
And if we've done it correctly, now we
should have a chart that actually shows
the language and the proper labels.
So we'll run it again.
It takes a moment, again, to reach out and grab
all the data, to do all the parsing that's involved,
and then to draw the chart.
The chart drawing probably is the fastest part
of this whole operation.
So we'll give it a second to work through all those steps.
And there we go.
Now it's not totally perfect just
because our labels take up probably more space than we
want.
But you can see that we've got everything in the right place.
So percentage of letter frequency,
letter of the alphabet, book versus language.
Compare English to this book, Which
Lady by Elizabeth Champion.
And now you could change the language.
And let's do that here.
We'll try this one more time.
Let's go over to changing the language.
And again, it would be good to extract this out
so we don't get confused about what language we're
dealing with here.
So it's these two here that we're dealing with.
This is setting it to English by item 2 and item 2.
This would be definitely something
that we'd want to refine.
But let's set it to 5, get a different language,
and we'll see how those letter frequencies hold up.
Because the whole goal of this was
to see if we could find the baseline letter frequency
compared to actual frequencies of letters in a particular text
and then be able to tell whether that text was
written in a particular language or not
just by the patterns of letter usage alone.
So now that we're comparing it with a different baseline
from a different language, we would
expect to see that this graph looks somewhat different.
And the further the language is from English,
probably the more different this graph
would look because the patterns of letter usage
will differ more greatly.
All right, so now we compare it to Spanish.
And you can see here that, in fact, we
are seeing differences.
There are definitely some different spikes here.
I mean, not totally different, not radically different,
but I think that you can see that it's not
quite as in sync as it was in terms
of the English comparison.
So we'll stop there.
But I would invite you to explore this further,
try out other languages in our list,
and see if you maybe, for example,
could find another book in Project Gutenberg that's
written in a different language and compared to English,
or maybe try to discover what language it was in.
So that's just a simple technique
to explore how you would do something that's not even
really advanced text analytics, but uses
the abilities that are built into NIST blocks
to grab information from a particular source, Project
Gutenberg, to do some analysis of these patterns,
and then to use our charting service
to bring out their relationships.
So thank you very much for watching today,
and I look forward to seeing you in my next video.
</p>
  

    <h2>11. map-keep-combine</h2>
    <p>Hi everyone. Welcome back to Programming for a Networked World.
Today, we're going to talk about another way of processing lists.
Sometimes you come across very long lists,
and it becomes tedious to use a for loop to iterate through all the items.
So, in this particular video, we're going to talk about an alternative
to looping through lists when you want to process every item in a list.
So, ready to develop your superpowers when it comes to crunching lists?
Let's get started.
Okay, we're going to be talking today about map, keep, and combine.
These three blocks provide really powerful abstractions for working with lists.
These blocks take a particular operation, or more generally speaking, a function,
and apply it to each item in the list in turn.
Let me bring out the map block so we can talk about it in practice.
The map block, as you see, has two slots.
It has a ring where we put an operator, and then it has a slot for the list.
And what it's going to do is apply the operation that's in the ring
to each item in the list in turn, and then return a new list to you.
That may sound a little abstract, so let's try something in practice to see how it works.
I'm going to take over this numbers from 1 to 10 block,
and as you know, if I click on this, it will create numbers from 1 to 10.
That's pretty straightforward, and I'm going to drop this into our list slot.
Now, if we just use it like it is, then you'll see that with nothing in the ring,
it simply returns the list back to us.
So here you can see that it just returned 1 to 10.
But the magic of the map block is that we can take an operator
and drop it into that slot.
So now let's imagine that what I want to do is to double each of the items in the list.
So we would just say times 2 here, and then, you know,
we have to keep the first space open for each item.
So 1 times 2 is 2, 2 times 2 is 4, and so forth.
The problem is that we don't want to go iteratively through this list,
select each item, and put it into that empty slot.
What we'd like to do is have this block take care of that for us.
So the magic of the block is that by leaving that slot open,
it will simply put in or interpolate each item in the list into that open slot
and then perform the operation.
So you can see now that if I click on this,
I get a new list back with the same number of items,
but each of the items has doubled.
So that's fantastic, right?
Now, what if you wanted to filter a list?
That is, take some type of Boolean operator and apply it to each item in the list,
and then return a new list with only the items that passed your Boolean operator,
passed that filter's test.
So let's say that I have a list of numbers, like we have 1 to 10,
but I want to filter out any odd numbers.
How would I do that?
Well, there is another block that helps you with that type of filtering.
It's keep items from a list that pass a certain Boolean test.
So you see that it's structurally similar to the map block.
So here, I can take that same list of numbers, I can duplicate it.
Oops, didn't mean to click on it.
Let's duplicate it, drop it here.
Okay, now what do I put in that ring to filter the list?
I need to think about how I would identify what is even and what's odd.
So I would use the mod operator for that, and a Boolean equals.
So here, I would say, okay, anything that's divisible by 2 without remainder is even.
We can just test that by putting in 2, and you see that that's true,
but if I put in 3, that's false.
So in the same way that we left a slot open in the map block,
for the map block to apply to each item of the list,
we'll do the same thing here with this block.
We're going to drop it into the ring, and then I'm going to say,
keep items such that they pass this test, and then apply it to our list.
So if we try this, you see that we get back, in fact, a list that's now been filtered.
All the odd numbers have been filtered out,
and we get a list that only contains the even numbers,
that's half the length of our original list.
Great, but there's one more thing that we can do with these blocks
that's really kind of fascinating.
We can also take a list and perform an operation
that combines all the elements together.
Now, you might say, like, why would you want to do that?
Well, imagine that you're trying to create a sum, for example.
So we've got items 1 through 10, but you might want to say,
okay, what's the sum of those items?
So if I wanted to add up 1 through 10, what would the total be?
So again, we can use the plus here to do that,
but here you have to think about, we're going to take 1,
and then we're going to add it to the next item in the list, 2,
and then we want to take 1 plus 2, 3, and add it to the next item in the list, 3,
and so on and so forth.
So we're actually kind of working with two slots here,
because as we go through the list, we want to have what's been accumulated
in terms of what's been calculated already,
and we want to have the new item in the list
that we want to add to that accumulating number.
So in order to perform an operation that combines everything,
we need to leave these two slots open in our operator.
And so here we will take, as I've already hinted, combine,
and it's got a similar format, although it puts the ring at the end.
And so we'll take the numbers 1 through 10,
and we're just going to take this plus,
and here we just leave both slots open.
And kind of incredibly, when you click on this, you get the answer,
that if you add up 1 through 10, all the numbers in that list,
you get the result 55.
So with these three tools in your toolbox,
you can process lists very quickly and very efficiently.
They're also, of course, combinable.
So if you want to apply a map to something,
maybe double the numbers, and then combine them to get a result,
you can do that.
We'll take our numbers 1 through 10 here,
we'll double everything, and then we'll combine it.
So here you can see that, in fact, it is double of what we had previously,
110, rather than 55.
There's lots of really creative ways that you can apply
these three blocks in combination.
And as we go forward in our course, we'll look at some of those,
particularly as we get results back from our calls out to network services
that may provide lists of lists, and we need to abstract from those lists,
gather information, and to turn them into new lists
that we can then use in our programs.
So thank you for joining me.
I hope that you'll try these blocks out,
and I'll see you in the next video.
</p>
  

    <h2>12. mapping</h2>
    <p>Hi.
Welcome back to Programming for Network World.
Today's topic is mapping.
So we use maps all the time in our daily life.
We have them on our phones, and we use them in our cars
to guide us from point to point.
And you can also use maps within your NetFlux program.
So today, we're going to learn how to bring up a map
and to locate various topics or places of interest
in the world on those maps.
Ready to get mapping?
Let's get started.
OK, so like any other service in Nest Blocks, mapping is an RPC.
So if we go over to our Network tab
and we click on the Call block here, we can drop down
and we can see that there is a entry for Google Maps.
And if we look at what's available here,
there's lots of choices.
We'll just try GitMap for now.
And you can see, we'll move Ada over a little bit.
You can see that there are slots for latitude, longitude,
width, height, and zoom.
So latitude and longitude allow us
to find the coordinate location of any place on a map
projection.
So that is really important information
about where to locate items in maps.
We'll get to width, height, and zoom in a moment.
But how do we know our latitude and longitude?
Well, we could look it up online.
But fortunately, there's also a block
for that within Nest Blocks.
We'll go down here.
And you'll see here that there is
My Latitude and My Longitude.
Now, when I click on My Latitude,
if you have an enabled geospatial lookup
within your browser, you may get this pop-up.
And you just want to say Allow.
So we're going to allow that.
And now, the next time I click on it,
it should come back with a number.
So that represents My Latitude.
And the same thing here for My Longitude.
Now, the easy thing to do is just
to drop it into the slots that correspond to that.
And we're halfway there.
And the width and the height of the map
actually have to do with the width and height of our stage.
So we can also get that information right here,
Stage Height and Stage Width.
Of course, you can just type these in as numbers as well.
But this just makes it easier so that your map will adjust
as the size of the stage adjusts.
So here, we see that Stage Height is 360.
And the Stage Width, oops, I put it in the wrong place.
Stage Height, there we go.
Stage Width, we didn't check to see what the Stage Width was.
It was 480.
And let's do a default zoom of, say, 9.
Now, if we click that, you'll see that it
will go out to get a map.
But we have that same issue we've seen in other RPCs.
It's a very small map.
And that's because, as you know, in order
to make this appear on the stage,
we need to go to the Looks palette
and say Switch to Costume.
So now we can say Switch to Costume,
bring this down here, and click on this.
480 will disappear, and a map will appear in its place.
And this shows you where I am right now,
recording this in Nashville, Tennessee.
But oftentimes, in your programs,
you don't want to just show where you are now.
You often want to look up where you might like
to be or show other places.
So let's design a program to do what's called geolocation.
We're going to pass in an address.
Then we're going to get the coordinate location
of that address.
And then we're going to pass that information
into our mapping RPC and display that place on the map.
And just to make this more fun, let's
imagine that you're going on a college tour.
You're thinking about what college
you might like to attend.
And you want to see where these places are on a map.
So we're going to make this possible for us
to type in the name of a college, get its location,
and then show where it is on the map.
OK, so to do that, let's start off with sensing.
And we'll ask a question here.
So we'll say, ask.
And we'll bring it up here and say, what college
are we thinking about?
How about that?
It's a question.
And you know that when you ask a question like that
with the ask block, that the answer is captured here
in this answer block.
Now, we need to use a different RPC to get those coordinates.
And that is also built in.
But it's not in the same RPC that we've been using.
So let's go over here to get our call block again.
Let's drop it down.
And let's look at what's possible here.
And we see, for example, right above Google Maps,
very convenient, is geolocation.
And when we drop down geolocation,
we can get a lot of different types of information
we can pass in.
Basically, we could pass in a street address, a city name.
We can see what's nearby.
We can ask about different countries.
So there's lots of things you can do here.
We're just going to use this geolocate.
And it asks for an address.
Now, you might think you have to give
like the street address of colleges
and go to their website and look that up.
But actually, it will figure this out for you.
This is the nice thing about this block.
For the most part, you can just type
in the name of what you're interested in.
And it will try to geolocate it for you.
So I might try, for example, Vanderbilt University
and try this out.
Let's see.
And now I get a list of lists, latitude and longitude.
So OK, we know when we get information back
in that form of a list of lists, we've done this before,
that we need to go over and start
extracting that information.
Because in order to pass in latitude and longitude,
we need to get those separately.
So let's do that.
And the easiest way to do that, perhaps, is to get a variable.
And we'll call this our place or maybe our college or maybe,
yeah, our college is fine.
So we'll call it our college.
And then here, we're going to call.
We'll have a block where we set that variable here.
And we're going to set our college
to the value of this RPC.
But we're going to use that answer variable here
to say what college we're looking for.
OK, so that's good.
That'll capture that information for our college.
Now, in order to be able to pass it
in as my latitude and my longitude,
we'll take that out because that always shows me
where I am right now.
And we want to show where I'd like
to be when I'm thinking about this college.
So here, we're going to take this item 1 of
and take another one here and do this here.
Same thing there, but we'll do this one will be item 2.
And we might need to look at this again just
to kind of get a sense of.
I'll copy this here, duplicate it,
just so you have a sense of what we're
trying to identify in this.
So again, type in, just for the sake of exercise here,
Vanderbilt University.
And when I click on it, OK, latitude and longitude.
So I need to get this number and this number.
So that's going to be here item 1.
It's going to be item 2 of item 1 and item 2 of item 2,
because that is item 1, but item 2 of item 1.
And this is item 2 and item 2 of item 2.
So let's just test it out with one of these
and we'll see if we get the right information here.
There we go, 36.
That's right.
And here, we should get negative 86.
That's right.
So that's the way that we need to be
able to capture that information coming out of our college.
So we'll put this down here for latitude.
This is the tricky one.
Which is latitude and which is longitude?
Well, we'll find out in a minute.
And here we go.
And we'll get these off the stage
because we don't need them any longer.
All right.
And we'll duplicate this variable here.
We'll just pull it out.
Oops.
And drop it in here and drop it in here.
Now, let's just try Vanderbilt just
to see if we've got this right.
So it should ask me where I'd like to go,
what college am I thinking of.
Let's say Vanderbilt University.
Click on that.
And we don't seem to have gotten there.
Oh, of course we did because that's where we are.
Let's try a different one.
That's not too helpful.
So maybe it's working, but let's try it again.
Let's try Harvard University.
Yeah, it's working.
OK.
And let's try Michigan State just
to make sure everything is working fine here.
So Michigan State University.
There we go, East Lansing, Michigan.
OK, so it's definitely working.
We've got our latitude and longitude
in the right places.
You can adjust the zoom.
So if you want to get a little bit closer,
you could type in, for example, 11.
We can just try this again.
So let's try my alma mater, Kenyon College.
And there you go.
So you can get a little bit closer even still
if you type in higher numbers, you'll get greater zoom.
Obviously, if you have lower numbers,
you'll pull back more and get more of the encompassing area.
OK, so that, I think, is where we'll leave it for now.
We're going to continue this exercise of learning
to display information on maps in our next videos.
But that's a short introduction to how to use the map
and how to look up information using geolocation
and then to bring us to that point on a map.
So thanks, everyone, for joining me.
And I'll see you in the next video.
</p>
  

    <h2>13. message-passing</h2>
    <p>Welcome back to Programming for a Network World. Today, we're going to be
building a texting application. We're going to be learning about something
called message passing in Netsblocks, and our goal today is to send a text message
to someone who's not actually inside our own project. Curious about how that's
going to happen? Let's get started.
So, to get started with this kind of project, you actually need two people or
you need to open up a separate web browser and run them side-by-side.
Fortunately today, I've got my colleague Brian Bruhl, who you know from all the
tests that you've had to do along the way, and he's going to be helping me out
in being my partner in this exercise. But don't worry, we'll also include
instructions on the site about how you can do this yourself if you want to try
it out alone. Alright, so messages. When you send messages in Netsblocks, you can
send them not only to sprites, but you can also send them across computer
boundaries. So the idea is very similar to what you might experience with email.
When you're writing email, it would be pretty limited if you could only email
other people on your own computer. You want to be able to email anyone around
the world. And so, to do that, you need to send a message to them with a
particular address. Now, the question I remember was when I started with email,
how do I know that person's address? Well, first of all, we need to think about, okay,
where do we find that in Netsblocks? So, in order to find where to pass the
message to, we need to go to this Room tab that you've seen before, but that we
haven't used up till now. And you'll see in there that I have a role. I'm in a
role called My Role, and below it is my username. Now, in order to set up the
environment in which we're going to communicate with these messages, we're
going to need to create additional roles. And I'll create a role, and then I'm
going to invite Brian to go into that role to write his piece of the program.
So this is really a distributed program. I'll be writing part of it, and then
you'll see Brian writing the other part of it, and we'll take it from there. So
to add a role, I can click here, Add a Role, and I'm going to call this Receiver.
And you'll see that it pops up, and there's a new role now in my room, but it
doesn't have anyone in it. It's empty. And My Role, just to make it clear, I can
click on the center here, and I can rename it. So let's give it a name called
Sender. So that's pretty clear. So we have Sender and Receiver. So this is just
going to be one-way texting. We won't try to make the scenario that we might
want to lead up to later, where Brian can actually text me back. I'm just going to
text him, and hopefully he'll get my messages. Okay, so now what I can do is I
can click on this. There we go. And I can say Invite User. And when I do that, I'll
see all the people that are on Netsbox at the moment. So I can see that I'm
there, but I need to look for Brian, and I need to find his username here
somewhere. And it looks like there it is, Brian. And so I'm going to invite him
into the role. And you'll see there that Brian now will be able to accept that
invitation, and in a moment his name will appear. And there it is, Brian. Okay,
fantastic. Now, the thing is, with these roles, they're like whole Netsbox
environments to themselves. So I want to make sure that when I'm programming, I'm
in the right role for what I'm trying to accomplish. So you need to make sure that
your name is under the role that you're using. So in this case, then, I can proceed
to make the script. Now, what kind of block do we need to be able to send
messages back and forth? Well, the main thing is, we need to use, under the
Network tab, this new block called Send Message. And let's just take this Send
Message out here. And you can see that it has a drop-down, and so it just is going
to send a message. And the difference is, between this type of
message block and the broadcast block that you've seen before, is that this
message block has space for you to put some kind of message payload. That is to
say, you can type something in, just like,
hello world, something like that. Or you can put a list, or you can put any
other type of Netsbox blocks inside there, and that will be the payload.
That's what's going to be sent with that message. The other thing is, we can target
this now to the particular role that we want it to be sent to. So I can
send it to Receiver, I can send it to others in the room, or I can send it to
everyone in the room. In this case, I know that I want to send it to the Receiver,
because that's where Brian will be waiting for this message. So I can just
say, okay, send to Receiver. Now, as far as it goes, that's actually all we need. So
once I click on this, there, the message was sent. It's very anticlimactic from
our end, because I sent a text message, essentially, and we're going to have to
switch to Brian for you to see what that message looks like. Hey guys, it's Brian
here. Now that Cliff has shown us how we can send messages, we're going to check
out how we can receive messages. So first, we can, while we're in the Receiver role,
we can see that there are, of course, none of the scripts that Cliff has
written. Now, this is because, as he mentioned earlier, we can think of these
as independent projects. They don't share any code, or the stage, or sprites, or
anything like that. Now let's get started writing the script to handle the
message Cliff is about to send. If we check under the Network category, we can
see right above the Send Message block, we have this When I Receive message
block. And if we select the drop-down, we can see a familiar message type called
Message, which should look a lot like the message type that Cliff showed
you just a minute ago. And now the question, I guess, is what would we like
to do when we actually receive a message? Well, for now, let's just have our sprite
say the message, so we can see what has been sent. Alright, and now we can
see that the message has, in fact, been received, and we see our Hello World
message as soon as Cliff sends it. So now that you've seen what it looks like on
Brian's end, let's make this a little bit more complicated. We want to build, like,
an actual texting app. So how would we do that? Well, let's start building out
the app part of it. So I guess we can go to Control, and we'll bring over
green flag clicked, and let's ask a question that, you know, because you
typically text people some message, something of importance. There was that
app called Yo, and the only thing you could text was the word Yo, but I don't
think a lot of people text that way. People tend to, like, actually text
something of significance. So let's make it possible for people to do that. And so
we're going to go under Sensing and ask, What's your name? And that will allow
Brian to know who's texting him. So I'm going to then take a variable, and I'm
going to set it to, let's see, under Variables here, let's make a variable
called Name, and I'm going to set that variable, we don't need to show it though,
to whatever the answer of this is, and get that under Sensing. So if we go over
here, get the answer, pull it over there, there we go. Now, what else do we need
here? We need to just now fall into a loop that's our texting loop. So let's do
that, and let's go over and get a forever block, bring that over here, okay? And
we'll just continue to ask questions and then send text. So I'm going to drop this
in here, because we'll edit that in a minute, but we need that send message
block. The other thing we need is another block that says, Ask, and this is, What is
your message? And wait. And then the answer to that, we're going to drop in
here, so that's actually what's being communicated. Now, if we want to make
this a little bit more of a kind of distinctive message, because you see
here that we're sending only the answer, but we've forgotten to include my name,
we need to actually change this message type. So the other thing that you can do,
and that you'll find yourself doing a lot, is not just sending this generic
message, but sending very particular types of messages. And you might ask, okay,
well, how do I define the type of my message? And conveniently, there is a
button here that says, Make a message type. When you click on that, you get this
sort of starter message that you can customize. And so I'm going to call this
Chat, and then it asks you for fields. And just like any other block, you can expand
or contract that by hitting those arrows at the end. And so I'm going to
send two pieces of information here. So my message payload now will include two
different types of information. The first is going to be my name, and the
second is going to be, let's call it the message. Now the important thing about
this is, when you create that message type, and I'm going to drop down, you'll
see it appears as Chat, and my answer pops out. The important thing is that the
person that you're communicating with in that other role knows what that type of
message is, because it needs to correspond exactly. If you don't actually
have the same name for your message type, or the same number of slots, for example,
you're not going to be able to send messages that the other person can
receive. So this is something that you need to agree on in advance. And once you
have that agreement, then you can continue to reuse that type over and
over again. So here, I'm going to take the answer, and this, let's just be clear
about what answer I'm using. So I'm going to take over my name, which is available
here, and drop it in the name slot. And then for what is your message, let's get
that one from Sensing, and bring over the answer here. So I'm going to put that in
there. And again, I'm going to be sending it to the receiver. We have the other
options that we saw before, but we'll stay with the receiver. So that should be
the complete program. So let's try it now. It'll say, what is your name? Oh, you
know, we should be inviting Ada to ask us what's our name. So that's a missed
opportunity, but we'll add that in the future version of this. So in any case,
the turtle is asking us, what is our name? And I'm going to say, Cliff. And now it's
going to move into that loop. And it'll say, what is your message? And here I can
say, hello, Brian. And I'll say, how are you today? Again, a little anticlimactic
on our end, because we're not seeing the messages coming through. But we'll switch
over to Brian now, and see what it looks like on his end again. Now that we've
seen how Cliff has extended his sender role to be able to be more feature-rich,
including asking for a bunch of messages in a loop, as well as including the
sender's name, we need to update our receiver role accordingly. And so most
importantly, we need to update the message type to this new chat message
type that Cliff created, just so that both the sender and receiver are speaking
the same language, so to say. So just like, again, we saw a minute ago, we will
click on this make a message type button in the network category, and create the
same message type that we saw Cliff make. So we're going to be creating a message
type called chat, where the first field is name, and the second field is message.
Once we've created this message type, we can see that it has now become available
under the drop-down for the when I receive block. So we can select this chat
message type, and now we can see that the two fields that this chat message
contains are actually available. So in other words, anytime we receive a chat
message, if we want to know the name that was sent, it is available with this kind
of name variable block, and the message field is available using this
message variable block. So now that we have two kind of bits of information
that we would like to say, or like to kind of preserve, we can't just, of
course, fit both of them in the say block anymore. So we're going to need to go
into the operators category, and find some way to kind of join both chunks of
text. Thankfully, there's a block for that. So we can use this join block that we
see here. And just to keep it simple, let's maybe just say the name, put a
colon and a space, and then the message block in next. Now you'll notice that I
accidentally clicked on it and got this little error message. This is just
because the name and message variable blocks are really only available when we
have this, when we received a chat message, because we don't have, of course,
variables for these defined in this project. So if it happens to you, just
don't worry about it for now. Once we drag this within the say block, now when
we receive a chat message, we can see that we'll have access to the name field
and the message field, and it will say the contents of the name field with a
colon and a space, and then the contents of the message field. And as we'd
expect, we can see the message that Cliff sent a minute ago, and we can see
that Cliff is saying, hello, comma, Brian, exclamation point. And now we see the
second message as well, Cliff asking how I am today. And unfortunately, right now
we can't send messages back, so we'll just have to maybe let them know next
time we see them. Okay, today, just to review, you learned about message passing in
Nest Blocks. We learned how to use a room and to set up roles, and then we learned
how to use messages to communicate between those roles. We also learned how
to use message types to set up complex messages that we can then use to send
lots of interesting bits of information that we couldn't fit into single fields.
So with all that now, we can build larger distributed projects that we'll be
working toward in later parts of this class. Thank you for joining me, and I
look forward to seeing you next time.
</p>
  

    <h2>14. movie-lists</h2>
    <p>Hi everyone, welcome back to our series on programming for a networked world.
In this video, we're going to the movies. Well, to the movie database at least. Our project is
going to query this online database to find films with particular words in the titles.
We'll then loop through the results, writing the titles on the stage. Do you know how many
treatments of Frankenstein there are? After this nifty exercise, you will. This exercise combines
a number of programming concepts that we first met in other videos, including for loops, lists,
and variables. You'll see how we can combine these elements to create a sophisticated program,
and you'll also get a sneak peek at Netbox's ability to connect with data sources across
the internet. All right, ready to channel your inner film critic? Let's get started.
Okay, so we're going to retrieve movie titles and list them on the stage. We're going to build
this program block by block, and I want to explain the thought process as we move along,
but I want to talk a little bit about the call block from the red category before we begin.
So let's take a look at that block now. Here I'll bring it over, and it's under the network tab.
Here we go. Call. Okay. This call block with its companion run block allows Netbox to make remote
procedure calls. That is, these two blocks allow you to connect with other systems and perform
some prescribed action. For instance, we're going to use the call block to connect with the
movie database API. The term API is short for Application Programming Interface. An API provides
the rulebook for interacting with another system. In Netbox, we use this call block to make remote
procedure calls to application programming interfaces. These calls allow us, among other
things, to request and retrieve information that we would not have otherwise in our program.
In this case, for instance, we're going to use the call block to search for movie titles
matching a given keyword, and then to display those titles in a list. To do this, we need to
use the drop-down menus to navigate to MovieDB, and then we're going to use the drop-down menu
to select the precise API that we want to call. So let's see over here. When we do that, we've got a
long list, and we want to go to MovieDB, and then we're going to select Search Movie, and you'll see
that now it's asking for a string title. Okay, let's add the term Frankenstein.
So go over here, put in Frankenstein, and what will happen when we click it?
We get back a list of numbers. So what do these numbers represent? Well, we can right-click here
and click Help, and we see that for the MovieDB database and the Search Movie operation,
that it searches for a given movie and returns movie IDs. So you can search for a title of a movie.
It will return to the title of that movie in the MovieDB database. The IDs themselves do not have
intrinsic meaning. To get to the titles of the movies to which they correspond, we need to make
a call to the MovieDB database again. So let's try that. We're going to take one of these numbers,
and then we're going to send it back to the MovieDB database to get the actual title of the
movie with that ID in the database. So let's try it with title 3, let's say 3103. So 3103, we call
that, and oh, we need to change this now to Movies, and we want to get the title of the movie. So we'll
move down here, and now it says, okay, ID 3103. Click on that. So that ID corresponds to the title
House of Frankenstein in the MovieDB database. So if you're counting, you see that we have to make
two calls to get the title. First, we query for the movie ID, and then we send the movie ID back
to get the title of the movie that matches that ID. So if we want to search for, say, 20 movies,
we need to make 21 calls in all. First, we get a list of 20 items, and those are the 20 IDs that
we're going to use, and then we need to iterate through that list, and we're going to use a
for loop for that to go find each of the titles of those IDs in turn. Not every API works the same
way, of course. Some allow you to pass a list of IDs, or the equivalent, and to receive a list back
so that you can reduce your calls to just two. In general, it's better to minimize your remote
procedure calls to avoid tying up other systems and to make your own program go faster. But in the
grand scheme of things, calling out 21 times to the MovieDB database shouldn't pose any problems.
So we'll be exploring a lot of the remote procedure calls available in NetsBlocks throughout
this course, and the team is adding new remote procedure calls all the time. But let's stop with
these preliminaries, and let's get started with the project itself. We've got our MovieDB search
movie title, and that will be a central block. But we don't want to just ask for Frankenstein,
we want to leave it open so you can ask for any type of movie you like. So let's have the program
ask a question. What movies would you like? Or maybe it should be which, to be more proper, right?
There we go. And then the answer will be contained in this answer. Now, when we make this call out,
remember we're going to want to keep this list in memory. We're going to want to iterate through it
20 times. So I think that we'll create a variable, and let's do that as a script variable. So I'll
put that right here, maybe at the top. And then we're going to set that script variable here
to the result of calling out to the MovieDB database for movies with that particular title.
Oh, and we need to change this to MovieList, say. Okay, so MovieList, and we'll change that then.
Okay, so when this calls out, this should set the variable to MovieList, and then we can
work with the results. All right, the other thing that we want to do then is have this program
right on the stage. So how should we do that? Well, we'll start with clearing the stage,
nothing's written there, and then I think we're going to have under Looks,
we're going to use Hide. Okay, so Hide allows us to hide the sprite so the stage is visible,
even though the sprite will still be able to write on the stage. So let's try that out.
There we go, and there's our question being asked. So, so far, so good. I'll just stop it right there.
Let's keep going. Okay, so now we've hidden Ada, and we're ready to write in the stage,
but how do we write in the stage? Well, under Pen, we can go over here, and there's a
Write on the Stage. Now, the thing is, if we just click on Write in the Stage, hello, size 12,
it'll just put it right in the middle where Ada was standing. We actually want to set the coordinates
so that it writes in the right place, and let's do that by moving it. And so we'll start,
let's say, we'll start by going to a particular point in the stage,
and I think, so the x variable here, we probably want to have it negative 150,
and the y at maybe negative 100. Let's see where that moves us.
I don't know. Okay, so we need to have the y at 150. There we go.
Okay, that looks about the right place to be writing, and so then every time we write,
we want to sort of move down a little bit so that we don't just write on top of our
results as we go along. So let's see how that works. Stop here, and we're going to put the
write in, but now when we're writing this out, we're not writing out the list. We want to write
out each of the titles in turn, and this is where we need a for loop. So let's go over here to
control, and we'll grab our for loop, and we're going to drop it in here. And how, you know,
how many results do we want to iterate through? Well, it depends on how many results came back
from our query initially to the movie database. So we'll go over to the variables, and we're going
to get the length of whatever came back here. So let's go to length of, and we'll say the movie list.
There we go. So we're going to iterate from the first item in that list until the last item in
that list, and then we're going to do something. Namely, we're going to write on the stage,
but we still haven't called out again to get the actual title. So let's put that in,
and we don't need to create a variable necessarily for that. We can just take the call block over,
and we can drop it into right here. Drop this down to movie database.
It's over to movies, and we're going to get the title, and now we just need to pass in
the id from that list. So what id is it? Well, the iterator will tell us.
It's number one, number two, number three, and so on in that list. So now we need to go back to
variables and just get this item one of right here. And so it's not item one of anymore, it's item i.
That's the iterator that we're using. So each time that we iterate, as I said, that will increase by
one automatically, and that will help us to move our way through this list. And so we'll just put
the list here. It's our list of movies, and then we can write it in size 12. And again, the one
thing we need to do is move down a little bit each time so that we're not writing on top of each other.
So let's do that with move, and basically we need to kind of do two things. We want to sort of set
the margin back on the left-hand side, so we'll set x here because x will always be at negative 150.
And then with y, we're going to change y by negative 10. So x will always go back to the
same place, but y will continue to move down the screen as we go. All right, and
I think that's good. Let's give it a nice hat block to get started, so we can start with a click.
There we go. And with any luck, this should work. So what movie should we like to see? Let's say
Frankenstein, and there we go. We get a nice list of movies. Now if you want to be even fancier,
you could take the iterator, for example, and make that an ordered list. Let's take a look here. I
want to go to operators, and I want to join here two things. One is going to be the title. Well,
actually, let's expand this a little bit. You can see that you can expand that block, and I'm going
to pull in this. This will just be a space, and then I'm going to use the iterator here.
And so now, instead of writing hello, I'll have, let's put a period there too. That looks
very formal. We'll have one dot the name, two dot the name, and so forth and so forth.
And let's change the size a little bit, so it's a little bit bigger.
And I've got to make sure I'm spelling it correctly too. Frankenstein.
Okay, so let's review what we learned in this session. We saw how to call out to a data source
on the web using an RPC, and then to pull back data in the form of a list. And then we used a
for loop to iterate through that list one item at a time and print its title on the stage.
So why don't you try this for yourself and share in the comments how it went,
and I'll see you in my next video.
</p>
  

    <h2>15. ner-for-people</h2>
    <p>Hi, everyone.
Welcome back to Programming for a Networked World.
In today's session, we're going to continue
our exploration of natural language processing.
In particular, we're going to use
a technique called Named Entity Recognition, or NER.
We're going to use it to explore headlines in the news
and then pull out items of information
that we're interested in.
So ready to find people in the news?
Let's get started.
OK.
So for this project, we're going to use two RPCs.
And let me bring them out just so we can see what they are.
So the first RPC under Network here
is going to be where we get our news.
That's the New York Times here.
And you can see that it gives us options
to pull various pieces of information from the New York
Times.
We're going to go with Articles.
And let's go with the most popular.
And let's get the most viewed.
And that's going to give us a time period to choose from.
And let's pick for the week.
And so what happens when we click on this?
We get back a list of lists.
And we'll look at that later.
But it gives us basically the titles
that we're going to use to do some Named Entity Recognition.
The second is the Core NLP library here.
So this here should be under Language, Core NLP.
And here you see that it has what's called an annotator.
And you can annotate.
And then it says Get Annotators.
This will be a list of the annotators that we can use.
There's a whole bunch of things that we can explore here.
But today, we're going to be using the Named Entity
Recognition Annotator, NER.
So we'll go down and drop to Annotate.
And it asks us for a text and then the annotators.
Now, you notice that it's in plural.
So it actually wants you to give us a list of the annotators.
And let's just put this in list form
that we're only going to use that one.
And we're going to say NER.
So that should set us up for the RPCs that we're going to use.
Now, just to test this one to see what it looks like,
let's say this is Clifford Anderson's test.
OK, so we'll pass in some text.
We'll use this NER.
And then it's going to pass us back a sentence
with some value here.
Click into that.
And then we get three more lists here.
You can see the index 0.
There's entity mentions.
And then within entity mentions, there's
information about an entity that was mentioned.
And you can see here that this particular entity,
it identified Clifford Anderson as a person.
And it gives a confidence score here of 99%.
So we're 99% sure that I'm a person, which is a good thing.
So we'll use this technique of using the named entity
recognition.
But we're going to run it over the headlines that
are most popular in last week's news.
So in order to get this started, basically, this whole session
is just going to be working with lists.
And so we're going to be using our higher order functions that
work over lists, namely the map, keep, and I think
the other one, I always want to call it reduce.
But it's not called reduce.
It is called combine.
So we're going to be using those three, map, keep, combine,
in what follows to work with the lists that
come back from these RPCs and kind of drill down
to the results that we'd like to see.
OK, so let's get started.
And we'll use a bunch of variables throughout this.
So we might as well get that going here.
So let's go over here and just set up some script variables.
And the first one we'll just say is
going to be articles, say.
OK, so we'll get the articles.
And then we're going to set articles here
to the New York Times.
And so that part is pretty straightforward.
Now, the next thing we want to do
is when we get the articles back,
we want to be able to look and see what we got back.
Just the article, well, we always
need to have a control here.
We need to have the report block.
So let's report that.
Now, this is a little hard to read.
So let's just report for right now maybe the first row.
Take a look.
And here's the information that comes back.
Pull this over a little bit.
OK, so here's the title of the article.
This was Trump pulling a Putin amid the current crisis.
There's an abstract.
There's the byline section and everything like that.
So you can see here that what we want is the title.
Now, the easiest way to get the title
is to go back to our library.
And let's just open this here.
We want to import a library.
So let's go to Libraries.
And we want to use the Structured Data Library.
Here we go.
So pull that in.
And now under Custom, you can see that we've got value of.
So let's just substitute this item one of and say
value of title.
So probably need to, my guess is,
we're going to need to map this.
Let's try that.
All right.
Here we go.
Let's try that.
Now, let's see how that works for us.
There we go.
Now we have all the titles.
So the problem was we needed to go one step into the list
and then we went to map over each of the rows
in that long table and get the title out.
So now we've got the title.
But to pass this in, we could pass it
in as that 20 or so titles.
But it would be more efficient to actually combine
these titles together and then pass them all at once
into the RPC so we don't have to make 20 different calls out
to Core NLP.
So the way that we'll do that is we'll combine all these titles
into one.
Now, if we just combine them by joining this title like it is,
there won't be a space between the titles.
So we should probably put in a little space first
before we do that.
So let me just do that here.
I'm going to join.
And we'll just join a space at the end
just to separate out the last word from the first word
of the next title.
And I'm going to pull this in here.
And let's just take a look to see if this is working for us.
Should just put spaces in between.
So there's a space here at the end.
Now, how do we actually get this into a single list?
Well, there is that join here.
But this is meant for here's two strings.
How do you pass a list into this?
Well, here's a little trick.
So let's close up these spaces, these slots.
So it has no slots at all.
And I'm going to pull this map down.
I'm just going to drop it there where
there's no apparent slot.
And you see that it actually changes now to join input list.
So now it's going to join the strings that
come back from that map into a single string
without having to have a number of slots
open for each one of those strings.
It'll just assign those slots automatically
based on the length of the list.
So we click on that.
Now you can see, if you look at this,
it's kind of hard to see, that we've
got a set of titles, all one next to the other,
but with a space in between.
So that's what we wanted.
So now that we've got that information,
we're going to set that to, let's call it, title.
So I'm going to make another variable here,
call it titles.
Then we're going to set titles here.
That should be titles.
OK.
I'm going to set titles here to the call out to Core NLP.
OK, so we're on our way.
Now, let's just see what comes back when we report that.
Take a look again, sort of see where we want to go next.
OK, so we're calling this out.
But here's the thing.
Oh, OK.
Sorry, this should be what we set here.
Getting ahead of myself.
So we're going to do that now.
Let's call out to Core NLP and sort of see
what comes back when we send titles
into the annotation here.
So there we go.
Let's try that.
Again, we get sentences, and then we get this list of lists,
and then we get this entity mention.
So there's a lot of information coming back.
And we kind of want to drill down and be able to just
get to the results.
So how can we do that?
Well, first, we could go over here and under our custom,
let's use this value and just get the sentences here.
So that gives us one step in.
OK, now let's take a look at what comes back.
OK, that's good.
And here now we have the entity mentions.
And the entity mentions here has information
about the people that are mentioned.
So that's what we want.
We just need to be able to get to those.
So let's do that again.
But now we're going to need to map over this.
So I think this is maybe a good place for us
to maybe make another variable.
So let's just call this one Sentences.
So we don't get too complex as we go forward.
And let's assign that to a variable here.
There we go.
OK, so now that we've captured it in sentences,
we want to drill down a little bit further.
And so let's do that again with another map.
So we'll report this information here just as we build this up.
And let's go over and get our map again.
Here.
And let's map.
And I believe that term was entity.
Well, let's take a look, because I don't remember offhand
what that term was.
So let's take a look.
OK, entity mentions.
So that's what we want to use here, entity mentions.
So let's see if we can get that out.
Entity mentions over sentences.
All right, try again.
OK, so now let's see what we've got here.
These are entities, in fact.
And there may be, you can see here, quite a few
and of different sorts.
They're not all people.
Some have to do with money.
And some have to do with number.
Some have to do with ideology.
So there's a lot that's here that we probably
don't want to have if we just want to look at the people.
OK, so what we could do then is filter this.
But in order to filter this, let's
make this list a little bit easier to read.
So we're going to call this, let's just
call these entities first.
All right, so we'll assign that value to entities.
And I think that one thing that we
could do to make this a little bit easier to read
is we could just take that list that's a little bit jagged
and make it a lot smoother.
And we can do that using a technique
that draws on combine and also on this append block.
So what we'll do is we're going to combine the values that
come back here from this map using this append block.
Now, what this will do is smooth out our list for us.
So now you can see that the list no longer is jagged.
It just has 34 entries here.
And only at the end, you see that you
get some extra information for some of these
that don't exist for others.
We'll ignore that for now, because what we're going to do
is the next step is we're going to filter or keep
certain items that match our criteria.
So let's do that next.
But first, let's assign this here to entities.
OK, so I want to set that block under variables.
Here we go.
And I'm going to set it to entities,
bring this over here.
OK, so our next step here is to filter.
And let's go over and grab that, which is
the keep block in nets blocks.
We're going to keep items that meet a certain condition.
And the condition that we want to meet
is that they have an NER value equal to person.
So as we saw, there was lots of other possibilities
for named entity recognition.
But in this particular case, we want to keep the persons.
So let's go ahead and do that.
So we will grab from custom that the value here of the NER
in the list is going to be equal to person.
And the way that person is spelled here is in all caps.
And that's going to be from entities.
All right, let's see how that looks.
OK, now we've got a much smaller list.
And we should see, and I think it's going to be here in H,
that now these are all persons.
That whole row or column, H, is going to be just people.
So the last thing that we need to do to make this a little bit
easier to see is to take out the keys
and only look at the values.
This is a little bit tricky, but we'll show you how to do that.
So let's just put here, we're going
to call this one persons because that's what we're
dealing with at this point.
So we'll drop this down.
And we're going to set this, let's go here.
OK, we're going to set this variable to persons.
OK, here we go.
And we'll, oh, didn't drop down.
Persons, OK, not sure why that's not dropping down.
Let's try it again.
There we go, OK, set to persons, OK.
Now, to get rid of the keys, we just
need to map and get the, for each of the columns,
they all contain a list.
They have an item that shows the first item of the list
is the key, and the second is the value.
We just want to pull out the values.
We're going to need to map twice to do that.
So here's how we'll do this.
Going to take this map, and then we're
going to take another map, put it inside there.
Going to take this person's list.
We're going to map here item two of,
and this should map over every row, and then
every list in that row, or item in that row, which
is a key value pair, and just take the value portion.
Let's try that.
And there we go.
So now we can see the results.
If I can pull this down, we've got seven different people
that are mentioned.
You can see the names here, and you can also see here
the confidence scores.
This is other information about where those items are found
in the text.
If we wanted to see the keys, we actually got rid of the keys.
We'd have to go back and look.
But for now, we've got a nice table
that indicates who exactly we're looking for here,
or we've discovered in the news, and these
are the people that were most mentioned in the news
during the last week.
Now, if we want to look about Benjamin,
I think we'd have to do some investigation.
But otherwise, most of the names here are fairly recognizable.
So that's what we'll do today.
That's the end of our session today.
You can see how named entity recognition works.
You can also see that when you're
working with these complex lists,
you really have to master that ability
to apply the different higher order list
blocks that we've looked at.
So that's map, keep, and combine.
And by using them, you can process these lists really
efficiently and get to the results that you'd like to see.
So we'll continue with our exploration
of natural language processing again next week,
but that wraps it up for this segment.
Thank you very much, and see you in the next one.
Bye bye.
</p>
  

    <h2>16. recursion</h2>
    <p>All right.
Welcome back, everyone, to Programming for a Network
World.
Today, we're going to be exploring
the topic of recursion.
Recursion is sometimes considered a difficult topic,
but I want to show in this video that it's really not
so bad at all.
So ready to explore recursion?
Ready to explore recursion?
Oh, did I say that already?
Let's get going.
OK, here's what we're going to do today.
We're going to build a project that computes factorials.
So for those of you that remember factorials,
factorials are the product of an integer
combined with all the integers that came before it.
So for example, a factorial of 3 is 3 times 2 times 1,
which is 3 times 2 is 6, and 6 times 1 is 6.
So the factorial of 3 is 6.
We're going to make two programs that compute factorials.
We're going to do it the traditional way with just
a loop, and then we're going to redo it
as a recursive function or using a block that
employs recursion.
All right.
So how do we do it the traditional way?
Let's get started with that.
So I'm going to make a block over here,
and I'm going to say make a block.
I'm going to go over to the operator here,
and then we're going to pick a reporter.
I'm going to call this, let's call it loop factorial of n,
and we'll create that.
Then I'm going to click here to make n an input that
takes a number.
OK.
And that should be good.
So say OK.
I'm going to bring this over here
and open it up a little bit more so we can
see this whole scripting area.
All right.
So the first thing that we need to do is make a variable.
So let's make a variable here called result.
That's going to be the result that we pass out
of this function or that we report.
And then we want to start a loop.
So let's go up to Control, and let's get a for loop here.
Now, we want to loop as many times
as there are integers in a number that
are previous in the sequence going down to 1.
So from here, we'll just count up
because this is commutative.
We can go either direction.
We're going to count from 1 to n.
So n will be, for example, 3.
Then we'll do 1, 2, and 3.
OK.
And now, we just need to think about what we want to compute.
So we need to get a variable set block here.
I'm going to set this.
Now, we're going to set the result to in here.
We're going to get an operator to i,
which is going to be 1, 2, 3 times result.
Now, if you look at this right here,
we're going to have a bug because result is going
to be initialized to 0.
So we need to remember that if we're
going to initialize it to 1, we need to tell it so explicitly.
So we're going to say set result to 1.
Otherwise, everything multiplied by 0 would just end up being 0.
And then at the end of this, we want to report.
Let's see, under Control, we want to report our result.
All right, so let's get that and pull down Result.
And that should be it.
So let's give it a try.
So now, remember, it disappears because it's now
under Custom, loop factorial.
And we can try 3.
And the answer should be 6.
And it is.
And 5 should be 120.
And it is.
You go up to 10, and it gets to be a much bigger number.
But that is the correct result.
So we built a function that computes factorials.
Great.
Now, how do we do this in a recursive way?
So when you're thinking about recursion,
the fundamental idea is that you create a block that calls
itself as part of its solution.
And in order to do that, you need
to make sure that your recursive block has two cases.
One's called the base case, and the other
is called the recursive case.
And you want to make sure that when you're computing,
that your recursive case is tending towards the base case
and will eventually reach it.
Because the base case controls when the recursion ends.
And if you never get to the base case,
then you'll just keep going over and over in a circle.
And eventually, your program will produce something
called a stack overflow or some kind of error
that runs out of memory or space.
OK, that might seem a little abstract.
So let's just put it together in a practical example.
So we'll make a block here.
And we're going to take this.
It's going to be an operator again.
And we'll call this recursive factorial of n.
And it will be the same as the other.
We're just going to turn n into an input for a number.
Let's get a number here.
There we go.
All right.
And again, let's just make a little bit more space
and start building this up.
So again, with a base case and a recursive case,
the best way to handle this is probably
with an if-then expression or an if-then-else.
So let's grab an if-then-else.
And the first thing that we're going to test
is the base case.
So the base case is when we reach 1.
We don't want to go into 0, because if we multiply,
as I said before, anything by 0, it's
going to be 0 as a result. And we don't want
to get into negative numbers.
We probably should be testing the input on the way
in to make sure that the input to start with is not negative.
But we're trying to keep this example simple.
If you feel like adding that on, that would be a great exercise.
If n is equal to 1, then we're going
to do something, which is we're just going to report.
Here we go.
Oh, I keep going to the wrong tabs.
OK.
We want to go to report n.
Now, you could also just report 1, because if n equals 1,
then you know the answer is 1.
But to keep it kind of nice and clean, we're going to report n.
So this is the base case.
So else is going to be the recursive case.
And I might even just make comments here.
So let's just add something here.
Let's say a comment.
And we can put it right there.
And we can say base case, just to make that totally clear.
Then we can make another comment and put it down here.
Whoops.
I guess it's harder to do with the else.
So we'll just put it down here in recursive case.
OK.
So base case.
And then actually, the recursive case is here.
So we'll kind of just put it off to the side.
That's the base case.
This is going to be the recursive case inside the else.
So the recursive case has to call this function again,
but with different inputs.
So what would that look like?
So here, we're going to do report again.
So we're going to report.
And that's going to help us to call this function.
Now, you say, OK, I want to call this function again.
But how do I reach up and call it?
Well, you can go to custom and actually pull this block back
in.
So we're going to do that here.
This allows us now to connect a recursive case.
Good.
And we're going to say recursive factorial of.
And here, what is it?
It's not n any longer.
It's going to be n minus 1.
So let's do that.
Because we're trying to move towards or converge
on the base case.
But there's one more thing that we need to do.
So here we go.
Recursive case of n minus 1.
We also need to multiply n times all the other numbers that
are in the line of integers until we get to 1.
And so to do that, we're going to take this multiplication
here, going to multiply this, and we're
going to multiply this by n.
So again, you can see this here.
There we go.
So we have the base case.
If n equals 1, then we just report n.
Otherwise, we report n.
That could be 3 times the recursive factorial of 2.
And then that will recurse.
And again, you'll have the same question.
Is it going to be the base case?
No, this time it's 2.
So then it's going to be 2 times the recursive factorial of 1.
And then it's going to go through again and say,
is it 1?
Yes.
And so it reports 1.
And then it calculates 1 times 2 times 3.
And you get your answer of 6.
So that's how recursion is done.
And let's just see if it works in practice.
So we're going to go over here to Custom again.
We're going to bring over the recursive factorial.
And I'm going to try again 3 just to test it out.
It should be 6.
It is.
Let's test it out as 5.
Should be 120.
It is.
And then we can test.
Let's try 10.
Now, you might say, OK, these are two ways
of doing the same thing.
Why would I even bother with doing recursion?
And the answer is it depends on the context.
In almost all the cases, with some very small sort
of edge cases, you can always turn a recursive operation
into a loop and vice versa.
But sometimes it's more efficient to calculate
something recursively.
And sometimes it's even easier to program it
because you're kind of focused on the logic of the problem
rather than the looping operation
and keeping track of the state of all those interim values.
You kind of let the computer do that for you
when you're doing recursion.
And depending on your programming environment,
doing a recursive function may actually
be faster and more efficient.
So let's just test this out here very unscientifically.
But I'm going to take a big number.
Let's try 50 for both of these.
And you'll see a noticeable lag, for example,
when I run this first one.
Calculates, and then we get it in scientific notation.
But you can see that it took maybe a second.
And we do the same thing here, and it instantly reports.
I don't even know if we can get up to 100.
Let's see if we'll go that high.
You can see that it probably took about two seconds
to calculate that.
And again, with this function, it's more or less instantaneous.
And we could keep going with that.
Again, we're going to hit an upper limit where it won't
be able to calculate this at all.
We got to infinity.
And we probably will reach infinity faster here.
So express train to infinity.
There you go.
But the point is, within NETs blocks,
sometimes recursion will produce faster results
than the traditional way of doing things
with looping structures.
All right, so that is our video for today.
I hope that was a useful introduction to recursion.
And I will see you in our next video.
</p>
  

    <h2>17. running-dog</h2>
    <p>Welcome back, everyone, to Programming for a Network
World.
Today, we're going to be continuing
our exploration of peer-to-peer networking within Netsblocks.
So we're going to take this a step further,
and we're going to take a graphic that we're
going to animate on our Netsblocks screen,
and then we're going to have that continue
to animate on another screen.
That is, to move from one program to another,
but have the kind of illusion of the continuity
of that animation.
So you could think about that technique
if you wanted to build a distributed video game
in some way, maybe even like a Pong game that has players
playing on different sides, and then
the Net is where your animation crosses over
to the other person's program.
But for today, we're just going to do the animation part.
And so to get started, let me turn
to Brian, who's joining me again,
and he'll help us get the animation going.
Well, hello, everyone.
Thank you, Cliff.
So as Cliff said, we're going to be
having this animation running from one computer
across the internet to the other computer.
So specifically, we're going to have
a dog that's running across my computer,
and then onto Cliff's, and then back to mine,
and so on and so forth.
So before we get into the networking portion of it,
let's first just try to break this problem down
into how can we animate this dog?
How can we get it to actually appear to be running?
So if we jump into our project right here,
we can see I'm starting from a starter template
where we already have a bunch of different costumes
which show each different, I guess, frame in this animation.
So if we want to show this illusion of running,
all we need to do is change to the next costume
that we have.
We can see that if I click this really quickly,
we get this kind of slow motion, and then we
get this kind of run in slow motion.
So instead of, of course, clicking a bunch of times,
if we want to do something over and over,
we might want to put it in a loop
so I can get this forever loop.
And now we can see that this animates way too fast.
So we can certainly slow this down
to something more reasonable by adding this weight block.
And now we can see that we have this animation of this dog
running at a reasonable speed.
So it's running, but it's running in place.
So we might want to certainly have this dog actually
move as it's running as well.
So we can drop this move 10 steps block into our loop.
Now we can see that the dog runs clear off the screen.
OK, so now we have this, the beginning of this program.
We were able to show this or animate this dog's running
across our screen.
But we certainly probably wanted to make
a couple of additional tweaks.
For example, when the program starts,
we probably want to start at the beginning of the stage.
And then it would probably be nice to know
when it runs off of the screen.
So let's start by looking at how we
might be able to get the program to animate
the dog running from the beginning of the screen
when the green flag is clicked.
So use this one green flag click block.
And then when the green flag is clicked,
we want to move it to the beginning of the screen.
So let's go to, say, 0, 0.
And that's not really where we want the dog to be.
We probably want it in the bottom left corner here.
So we can try something, say, maybe negative 150 for x.
Let's maybe make that negative 175.
Now I can see we're right at the beginning.
Negative 150 for y.
This looks like it's about right.
We've got the dog in the bottom left corner.
And now we probably want to start
at the beginning of the animation.
So we can switch to costume dog 1.
So now we started from the beginning of the animation.
And then we can just broadcast some sort of event.
Actually, let's not worry about the broadcast just yet.
Then we can actually just have the animation start.
So now if we click green flag clicked,
we can see the dog starts in the lower left
and runs across the screen.
So it's looking pretty good.
Now we just need to figure out how
to tell when the dog is off the screen.
And then Cliff can jump right into the networking portion.
So if we're going to run until we're off the screen,
we probably want to make a new variable that keeps track of if
we are still on the screen.
This variable should start with a value of true.
And then when we are doing our whole animation portion,
we want to probably only repeat that
until we're off the screen.
So repeat that until we are actually
no longer on the screen or not on screen.
All right.
Now we throw out a forever loop because we're not
going to be doing this indefinitely anymore.
And to make this a little simpler,
I always want to get into the networking portion
since we're also going to need this animation.
But let's put this script out on its own
and actually broadcast an animate event.
So now when I receive this animate event,
we'll just do the animation while we're on the screen.
And let's give this a try.
If you press the green flag, we can
see we're animating, animating, animating.
But we're off the screen now, and our onScreen value
is still true.
And the problem is that there's no point in this loop
where we're checking to see if we're still on the screen.
So now we just need to add one more block or one more bit
here where we're setting this onScreen variable
to some expression that determines if we're still
on the screen.
So let's see.
We know that our x position is going to be
the important value here.
So we can actually just try to figure out
what the value of x is when we're off the screen
by just running it and just trying to stop it right
when we get off the screen.
There we go.
Let's say 305.
So this is a little bit simplistic.
And there are certainly other ways to do this.
But for now, I think this is sufficient.
So we're just going to check to see if this x position value is
greater than, let's say, 305.
All right, so now when we, whoops.
So this is actually, so you can see I actually did the opposite.
So I was determining how to tell if you're off the screen,
but this variable is whether or not you're on the screen.
So we want to just change this to a not.
We also could just change the sign on the inequality.
All right, so now we see we run off the screen.
And as soon as we're off the screen, onScreen is now false.
All right, so now up until this point,
we've been able to create a running dog where
we animate this running dog moving across our screen.
And we know as soon as it gets off the screen.
Now, once it's off the screen, we're
going to need to have it show up on someone else's computer
and then run across that screen as well.
So I'm going to go to the room and duplicate my role
and name this one Role2 so that when Cliff joins the role,
he'll have the same set of costumes.
So he has everything needed to animate this running dog,
including the scripts that we've made up until this point.
Now, I'm going to invite Cliff and turn it over to him
to finish the networking portion.
All right, thanks, Brian.
So you see I get Brian's invitation.
So I will accept that.
And then, as Brian said, there's his project.
So I get that on my screen, which is fantastic.
You can just double check to see which room I'm in.
I'm in Role2.
I'm in the room, and I'm in Role2 here.
So that's good.
And the only thing is, remember before,
I need to get permission from him
to be able to change his project.
So I'll request permission from Brian.
And now that he's granted that to me,
I can start coding on my side.
So what I need to do then is, as we've seen,
the dog will be running across the screen.
And then when it hits the edge, it stops.
And that's the end of the program so far.
So in order to flip back and let the dog continue
running on Brian's end when it's off the screen on my end,
I need to send a message to Brian.
So I need to use this send message block.
Now, we want to send the message as soon as that block has
turned to that we're at not here.
So let's see.
When we receive, we're going to repeat
until it's not on screen.
So this is setting that as not on screen.
So then after that loop ends is the place I want to put it.
Now, the question is, what do I want to send?
So there is a built-in message.
But we can actually customize your messages.
And this is important because you
may be sending various types of messages back and forth.
And they may actually contain different types of data payload.
And so here, we're going to customize and create
our own message.
The thing is, when you're building a distributed program
like this, it's really crucial that you
know what the type of message is that you're sending.
Because if I just send him any message with any name
and Brian doesn't know what that name is,
he won't be able to know what to receive.
So let's just create here a make a message type.
And the name of the message is going to be,
let's call it Enter Dog.
And the field will be, now, what should the field be?
What kind of information am I trying to pass back?
Well, again, to preserve the continuity of the animation,
we actually want to know where the dog is
in terms of its gait.
Like, what is it doing when it's running?
Are its legs together or its legs apart?
And in order to know that, we actually
just want to pass back the number of the costume
that we're using.
So the costumes all have these numbers here.
And even if they weren't numbered themselves,
there are a numbered sequence here.
So basically, what we want to say
is whatever costume number we're on
is what we're going to pass back.
So I'm going to say I'll call this field Costume Number,
just so that's clear.
And so now I have that available to me.
And if I drop down here, I can say Enter Dog.
And you can see that it says Costume Number.
Now, the costume number I can get under Sensing.
And here it says Costume Number of.
And I want to drop down to not the stage, but the dog.
And if I click on that, it'll tell me
that it's right now in 4.
But we're not going to hard code that, of course.
We're just going to drop that in.
Let me make sure I get enough space for you all to see that.
OK.
So that's going to be, oh, wrong slot.
There we go.
And then I need to send this to role 1.
So the message will go back to the role that Brian's in,
but containing the information that Brian
needs to keep that animation smoothly running.
Now, the other thing is, when I receive a message back
from Brian, I'm going to need to also handle that on my end.
Otherwise, it would just be like,
as soon as it runs off my screen,
it would never come back.
And so we'll go to Network here.
And we're going to take When I Receive.
And I'm going to drop this down.
And I'm going to get that same message.
So whenever I receive an Enter Dog,
then I need to handle that with some animation on my end.
Now, remember, I'm getting this message
when the dog has run off the side of Brian's screen.
So it should make an entrance on the left hand of my screen
as it continues to run across.
We actually already know where that is.
If we just duplicate this block up here and I pull this down,
that's the starting point.
It's already in there.
Now, the thing is, switch to costume Dog 1.
That's where we need to say, no, it's actually not Dog 1.
It's the costume number that comes through
when we receive that message.
So we'll replace that.
We want to set onScreen to true.
And then we're going to broadcast back to animate.
And that will do the animation running all the way
through until it reaches the end and it's not on screen anymore.
And then we send the message to Brian
to continue the animation on his end.
Brian, I think we've got all the pieces in place.
What do you think?
I think so.
Let's give it a try.
All right, now let me bring my screen
and make it a little bit bigger.
So here we go.
And since you're in role 1, why don't you kick us off?
Sounds good.
Here we go.
There he is, running across the screen.
And then back to Brian, running across the screen.
And we did it.
We did it.
So this dog will just be running forever
unless we give it some instructions otherwise.
But you can see that this could be a great foundation
for building a distributed video game.
And so today, we've learned two things.
We've learned how to animate the sprite on your screen
so that it has an illusion of motion.
And we've also learned how to customize messages
so that we can send a custom message
type with different types of data payload
when we're trying to do something that's
more sophisticated than just saying, hello, world.
We'll stop it there.
But thank you for joining us.
And we look forward to seeing you in our next video.
</p>
  

    <h2>18. scrolling-map</h2>
    <p>Hi, everyone.
Welcome back to Programming for a Networked World.
In today's episode, we're going to be continuing
our exploration of mapping.
But today, we're going to see how
we can make a map more dynamic.
We want to be able to scroll around on the map
and see what exists over the map's horizon, so to speak.
So ready to explore the world by scrolling through maps?
Let's get started.
OK, so we'll begin today, just like we
have in other ones of these particular series,
by bringing out a map and displaying it on the stage.
So here, I'm going to go over to get our block for the map
and go down to Google Maps.
And then we get to Google Maps.
Here we go.
Let's see.
We're going to Git Map.
There we go.
OK, and we've got latitude, longitude, width, and zoom.
We'll fill all that in.
But we want to start with our latitude and longitude.
So we want to actually look up where we are.
So let's go back over here to Network.
And let's pull out the call block here.
And let's get the geolocation, RPC.
And we're going to geolocate.
And we'll geolocate our address.
Let's just say Nashville.
OK, and we'll call this.
And we'll get our latitude and longitude.
Now, let's create some variables for that.
So we're going to be using this here.
So let's go to our Variable tab.
And we're going to make a variable.
And let's just call it one latitude.
How about just lat?
That's easier.
Lat.
And then we'll create one for longitude.
So we'll make a variable for lon, like that.
And then we're going to make a variable for the zoom.
OK, so we've got those three things
that we need here to fill in the various slots in Google Maps.
So let's assign them.
So we'll start by assigning a longitude.
And that's going to be here.
We need to use the item of block.
And we need to get to item 2 of item 1, I think.
Let's try that.
Let's try that.
So here we go.
We'll pull this down.
Oops.
Pull it down here and click on it.
And 36, I think that's going to be right.
That's the latitude.
OK, there we go.
So that one we should set to latitude.
And then let's do the same thing here.
But we'll duplicate this block and put it here.
And we're going to switch this to the longitude.
And now let's do item 2.
And let's see if we can set that.
So we have our lat and our longitude set.
And zoom we'll set later.
We don't need to display these on the stage.
So we're going to unclick those boxes there.
But we know we have that information captured.
And then we want to be able to put this into our map.
So let's go ahead and get the size of the stage
like we normally do from sensing.
So we'll go over here to get stage height, stage width.
Stage height, stage width.
And now we'll use our variables to fill in the rest.
So latitude here, longitude here.
And let's set an initial zoom of, let's say, 10.
OK.
So what we want to do is we want to set those variables up
when we first start our program.
And then we want to pass them into something
that will create the map for us.
So what we're going to do is we'll use a hat block here
to say, when clicked, we're going
to go to set these variables from our geolocation.
And we could make this a little bit more dynamic
by actually allowing people to choose what city they're in.
Maybe we ought to go ahead and do that.
So we can go to Looks, or actually to Sensing,
I guess, right here, and ask what city.
Or how about select a city or enter a city.
How about that?
And wait.
And then we can use the answer here instead of just natural.
So that'll help us to start a little bit more dynamically.
And now, we'll start it that way.
But then we need to call this particular block.
So here, we're going to actually use an event.
So we'll go over to our operators here.
And actually, I think it's under Control.
OK, Broadcast.
That's what we want.
OK.
So we're going to broadcast an event.
And let's just drop this down here.
And we're going to say New.
And we'll say, how about Show Map?
OK.
So we'll say Show Map.
And then we're going to handle that event.
So when I receive a Show Map, then we're
going to display on the stage.
We're going to switch to the costume of this particular map.
And we'll put it in this block here.
And we'll show that map.
Now, this ought to work at this point.
So let's try that.
We're going to click on this.
And we're going to say Nashville, like that.
And then, if any luck, it should show us the map.
Let's see.
Did we miss something here?
I think we didn't plug in our variables.
No, we do.
We have lat and long.
We just need to have zoom.
Let's see here.
Let's pull that over under Variables.
OK, so we'll get zoom here.
OK, so it should show it.
Let's just see if that works again.
All right, so pick a city.
We'll say, this time, Boston.
OK, yeah, it's working.
OK, so we didn't have zoom in before.
So it didn't know how to zoom in.
So we didn't see the map.
OK, now the thing is, we need to make it more dynamic.
We want to be able to actually move up.
Right now, if I use my scroll keys or arrow keys,
I can't move the map.
It's just a map that is what it is.
There's no way to zoom in.
There's no way to move up or down, explore the area.
So we want to make our map more dynamic.
All right, how would we go about doing that?
Well, the thing that we need to do
is just change slightly where our location is.
So we know that we have that location already here captured
in latitude and longitude.
So it would be simple, I think, to just say, OK,
let's just change that.
So we could, in response to a particular keystroke,
let's say an up arrow, we could add some code to handle that.
So let's go over here to say, when I'm
going to see if I get some space down here.
An up arrow is clicked.
Then we want to move up.
But how do we move up?
Well, we add to our latitude.
Oh, actually, this should be longitude, right?
Let's see.
So 42, let's see what's going on.
All right, so let's try this.
So we're going to take our lat, and we're going to add to it.
All right, so here we go.
All right, and so we're going to add.
But what do we add to it?
Well, let's just try adding one to it.
And then we'll call the map again.
All right, so here we go.
Let's do that.
When we do that, we just need to broadcast the map.
I guess we'll pull that down again here.
So let's go over to Broadcast, and we'll
broadcast that we need to recreate that map, the show
map.
OK, so that's in place now.
And so let's try the up arrow.
If we do that, you can see that we are definitely moving,
and we're moving up.
But we're moving up in a kind of,
it's hard to know how much we're moving at a time,
but more than we probably want.
It's actually hard to keep track of where we are.
So let's try this again.
I'm going to go back to Boston.
And you can see that one movement up
moves us way north.
So we can't just move up by one.
That's a little bit of an arbitrary number.
And the thing is, it also depends
on how far zoomed in you are.
Adding one to our latitude, when it's really zoomed in,
moves us a long way.
But when we're zoomed out, may not move us much at all.
So we actually need to know the relative amount we
want to move at our level of zoom.
We can do that with a technique of finding the max latitude
and the min latitude at a particular level of zoom
on the map, and then taking the difference between those
and using that as the degree to which,
or the number that we're going to use to move up and down.
So let's figure out how to do that.
So here, I'm going to write a little routine
to find that information.
You'll see that under the Network tab
here, we can call Cloud Variables again.
And if we drop down to the maps, we'll
see here that we have min latitude and max latitude.
Let's start with that.
So we're going to get max latitude.
Service is not available, but fortunately it is.
And we'll duplicate that.
And we're going to get the min latitude.
So that's going to be the latitude
at the top and the bottom of our map that's in view right now.
And so then we can take the difference between them.
And so I'll just pull this over here.
And we'll put the min latitude here and the max latitude
there.
And we'll get a difference between the top and the bottom.
Let me see if I can just pull this whole block over.
Here we go.
And so if I click on this block, you'll
see here that it's 0.359.
So that's showing us, OK, if you want
to move a full page view up, that
would be the amount that we would need to do.
But we actually don't want to move probably even that much.
We probably just want to move a quarter
of the screen at a time.
That gives us the sense of continuity
as we're kind of moving through.
So let me just drop this into here, if I can grab it.
There we go.
Get it in the right slot.
There we go.
I need more space over here.
So let's do that.
And I'm going to put in four into this slot,
if I can move it in the right place.
There we go.
So I'm going to put four right here.
And you can see now that we get this number that's
fairly small, but that will give us
a much more effective sense of scrolling through the map.
So now that we've got that, that's
what we want to use to figure out every time when
we need to set a variable to capture that information.
And then that will help us to know how much we need to move.
So when we regenerate the map with a zoom level,
we should probably also capture this information.
So what I'll do is I will create a variable up here.
Let's enter variables.
And I'm going to call it, let's see.
Let's see, I'll make a variable.
And let's just call it scroll amount.
And let's set that variable.
And we're going to put this down here,
scroll amount to this number.
OK, now let's try that again.
Let's bring our map back so we can see it here.
And I'm going to turn scroll amount off.
We'll just hit the green flag, get back to,
let's try Nashville again.
OK, so we're in Nashville.
Now let me try the up arrow.
Oh, wait, wait, wait.
I think the reason it's not working
is we haven't put the variable in the right place.
So let's do that here.
We're going to put scroll amount in here.
And now let's start again.
There we go.
All right, ready?
Now you can see the continuity of the screen
as we go into Kentucky.
So in order to get this to work as a full feature scrolling
map, we just need to replace this.
Let's see if we can do this here pretty quickly.
We need to handle all four events.
We need to do an up arrow.
Whoa, not sure what happened to that one.
OK, let's try that again.
So let's do this.
We're going to duplicate it.
Oops, just got part of it here, but we'll duplicate the rest.
There we go.
And then let's duplicate it again.
There we go, put it there.
Our scripting area is getting kind of crowded.
OK, so let's do up arrow and then down arrow.
Down arrow, of course, we want this,
but we want this to be subtracted.
So let's go over here and get that.
There we go.
So we want that to be subtracted.
And so that's the lat and the scroll amount.
There we go.
OK, and now let's do the same thing again here.
So we've got up, down, and now we need left.
And this one, of course, will be longitude.
So let's get that from variables over here.
So there's longitude.
Now, you might ask, do we need to capture
that information for the max longitude and the min
longitude in the same way that we did the max latitude
or the max, yeah, the max latitude and the min latitude?
The thing is, actually, those numbers
are basically the same.
So in this case, since our map is square,
we don't really need to worry about that.
We can just use those same numbers and it should be fine.
So we're going to just stay with the scroll amount that we have.
And then the only thing that we need to do here
is to also change this.
And I'll just kind of duplicate this one up here.
There we go.
Oh, no, let's get that back.
OK, let's duplicate it, bring it down here.
Then we'll switch this one out, grab the longitude,
subtract, and throw this in here.
OK, so we should be handling all of the events now.
So let's see how that works.
So we'll start again.
Let's try Houston.
OK, so we're in Houston.
Let's go up.
Oh, OK, that did not work as I expected.
So let's see what we did wrong here.
OK, one other thing that we didn't change, you see?
Simple bug here.
So the up arrow is setting the lat to lat plus scroll amount.
The down arrow, we need to change these
to the longitude and the longitude.
OK, so that's good.
Although, I don't see why that's affecting that.
Let's try it again here.
OK, Houston.
OK, I think we've got it working now.
Let's try it.
So we should be able to move around.
And there we go.
Now, there's one that's not working.
Let's see.
Just double check here.
So down arrow, left arrow, up arrow.
Oh, we've got up arrow in there twice.
Actually, I think that was the cause of the bug.
So now we want to go right arrow this direction.
Let's see if we've got that.
And we may actually have these backwards.
Let's try right arrow and left arrow.
There we go.
OK.
All right, here we go.
Bring this map over.
OK, up, down, left, right, up again, down again.
OK, so you see now that we have a scrolling
map, which is fantastic.
There's only one thing left that we have to do.
We have to be able to change our level of zoom.
So let's pick another when something key is pressed block.
And in this case, we're going to pick the plus.
And that will increase our zoom level.
And then we'll do the same thing,
but we'll do it in reverse when we get the negative.
So I'll just duplicate this here.
This is going to be roughly parallel code.
And we'll change that to a negative.
OK, so we just need to adjust our level of zoom.
So we came in with that default level of 10.
So here, we'll set.
And so when this plus key is pressed,
we're going to set the zoom to one level higher.
So let's go to get our variable zoom.
Here we go.
And we'll just say zoom plus 1.
And same thing happens, but in the other direction.
So we'll just duplicate this here, put this here.
And we'll set the zoom.
But in this case, we're going to go the other direction.
So let's pick it as minus.
And we'll put this in here.
And we'll subtract 1.
OK, so here we go.
OK, let's try.
Stop it, and we'll just run it again.
OK, San Francisco.
There we go.
Now, let's try zooming in.
I'm not getting a response right here.
Let's see.
We just click on this.
Oh, well, there's a reason.
You see, we've got the plus sign here.
But the last thing we need to do is use this broadcast.
So let's do that.
We'll bring this down here.
And we're going to do the same thing here.
Let's duplicate that.
There we go.
Because we have to obviously pass it back to the map
so that it can actually reset the level of zoom.
OK, and then in the map itself, we've
got the zoom where we expect it to be right there.
OK, so now let's try zooming out.
Let's see, there we go.
Whoops, that's zooming in.
No, it's zooming out.
OK, perfect.
There we go.
And we want to zoom back in.
There we go.
Now, the trick is, at the level of zoom that we have,
will our arrows work correctly?
And they do.
We're still getting the difference
between the max longitude and the min longitude
for the level of zoom we have in the map, which
means that we're scrolling at the right level.
So in the end, I want to thank kittyhacker101
for the idea of how to develop a scrolling map.
Although my technique is a little bit different than
that person's technique, I appreciate the inspiration.
So OK, in our next video, we'll sum up our work on mapping.
And look forward to seeing you then.
</p>
  

    <h2>19. shared-whiteboard</h2>
    <p>Hi, everyone.
Welcome back to Programming for a Networked World.
We're going to continue our exploration of networking
concepts in Netsblocks today.
And we're going to do that by interacting very dynamically
and graphically with each other's programs.
So we're going to return to this concept of a room that
has roles.
And our goal today is to develop a shared whiteboard.
That is, we're going to make it possible for me
to write something on the stage,
and then for that to show up on Brian's computer,
and vice versa.
When he writes something on his stage,
it'll show up in my computer.
So you could think about it as a collaborative whiteboard.
And so to do this, we're going to go back
to that idea of using messages to pass content
to each other with particular message types.
And to get us all started on this,
let me pass over to Brian, who's going to show us,
first of all, how we even start drawing stuff on our screen.
All right.
Well, thank you, Cliff.
So as Cliff said, we're going to be starting
with this shared whiteboard example.
So much like our running dog example,
where we were sending some sort of data payload
that was relevant for the application,
so not just displaying, but for knowing what costumes are set,
or things like that, we're going to be seeing something similar
here with our shared whiteboard.
Now, as Cliff mentioned, we first
need to start by just, rather than jumping right
into this collaborative whiteboard, where we're both
drawing and seeing what each other draw on our screens,
we're going to simplify this problem,
or break it down anyway, into just trying to draw
on our screen by ourselves.
So I've got this new project here, this shared whiteboard.
And I might rename this sprite something like, I don't know,
my pen.
And this sprite is going to represent, again,
the pen that we're using to draw,
if you want to think of it that way.
So the first thing we need is that when
we're moving our mouse, our pen, or our drawing tool anyway,
it should be following our cursor.
So if we look at the motion category,
we have a block that's the go-to mouse pointer.
And if we click it, we can see the sprite disappears,
because it moves all the way off the stage,
right to where my cursor is, which
is, again, over this block.
So let's put this in a loop, a forever loop,
and see if we can see that it is, in fact,
following our cursor as we move it around.
We can see that it is.
Now, you'll notice, though, that when I'm, well,
we'll see more of this later.
But we'll see that it is staying right on top,
and I think just underneath my cursor, which
will come up in a moment here.
Now, we probably want our program
to start when the green flag is clicked.
And when the mouse is down, we probably want to draw.
And when it's released, we probably want to stop drawing.
So we can use an if block here.
So if the mouse is down, then we can draw or put our pen down.
So now if we try this, we click the green flag.
I push my mouse down, and I draw.
And you see that it actually is into drawing.
So this is kind of odd.
But if you take a close look, you'll
notice that when I let go of the cursor, there is no shadow.
But when I click, there's actually
a shadow behind my sprite.
So this is a common gotcha when you're
building this application.
And if you look over to your sprite,
we can see there's a draggable toggle right at the bottom.
And if we click that, now we can't pick up our sprite.
So since our sprite was following our cursor,
when we clicked, we actually clicked on it,
and we're moving our sprite around.
So now we can see that we are, in fact, drawing.
But of course, even when I let go of my mouse,
it's still drawing.
And that makes sense, because if we look at our code here,
we can see that we don't have any point in this code
where we actually pick our mouse back up,
or pick the pen back up, so it's always drawing.
If we right-click on the if block here, we can relabel.
This is a little tip to convert our if statement
into an if else.
So if the mouse isn't down, instead of doing the pen up,
we'll put it down.
Now we can clear the whiteboard by just clicking this block.
We actually might also want to clear it
every time we start a new, start drawing fresh, so to speak.
So now if we click, we can see that the program is,
if we click the green flag,
we see that our program is running,
our sprite is following our cursor.
When we click and put the mouse down,
or click our mouse and move it around,
we can see we are drawing.
And now if I release, I stop drawing.
So now we have a very simple drawing application.
We might want to make a couple little tweaks
because this pen does look a little funny
at this kind of 90 degree angle.
So maybe we want to, say, point in the direction of,
I don't know, maybe over here.
If we try this, now we can see that we have an indicator
that looks a little bit more natural.
All right, so this gives us our simplest program to start,
where we're actually able to draw on the screen.
So now we can start thinking a little bit more
about the networking components.
And the first thing that we'll do is actually
create a new role and invite Cliff to it.
So we can start adapting this
to be a distributed application.
Now, rather than just adding a new role
by clicking this plus button at the bottom,
we can actually click on our role and just duplicate it.
So Cliff will get a copy of all our code
and everything too, so role dupe.
Now I can invite Cliff over.
All right, I got Brian's invitation here.
So I'll accept, and as you know,
I'll just move things around
and I get that request to be a collaborator,
so I'll request that permission.
And when Brian grants that to me,
I can move things around, so that's fantastic.
Now, one thing you have to realize,
because this is a distributed application,
the green flag clicked.
That means that the process kicks off on your own computer.
But if you're working with a process
that's on someone else's computer,
that green flag won't have any effect.
You're in a separate process from them.
So you actually need to send a message
to indicate that your program is starting.
So you can't just rely on the green flag clicked
to kick off a process on both parts.
You need to do that explicitly.
So what we'll do here is we're going to pull this out
and we're going to say, when green flag clicked,
and then we're going to send a message over the network.
And let's just call this message.
We're going to make it very simple.
We're going to call it start.
And we don't want to have any fields, because we don't need
to have any fields for it, just a plain token, basically,
saying that our program is starting.
So when the green flag is clicked,
I am going to send message start.
And we're going to send it to just everyone in the room.
So we could set a particular role,
but we might want to add more people to the shared message
board.
So we're just going to have everyone
when this starts.
Now, we also need to handle this ourselves,
because if you just click like that,
you send the message and nothing happens.
So we do need to then also say, when I receive, start,
just like this, and then we'll pull these blocks back up.
So now we're kicking things off.
When this starts, I'll receive start,
and then I can start drawing.
And Brian can start drawing.
Anyone in the room can start drawing.
That is if we actually have messages that communicate
what should be drawn.
So for that part, let me just turn it back over to Brian
to talk about how to set it up so
that what you're writing on your screen
actually gets sent out as a message to others.
Well, thank you, Cliff.
So as Cliff mentioned, we need to have some way
to communicate not just when the program starts,
but also what should be drawn or what has been
drawn by the other person.
So to be able to share this information,
we need to have some message type that includes this data.
So we're going to make a new message type,
and we're going to call it, let's say, draw.
We can give it two fields, one which I'm calling Xs,
or just spelling Xs, and the other one which
is following the same approach that's Ys, so Ys.
So once we define this new message type,
now we just need to think about what exactly
should this data payload be.
So we know we added these two fields, Xs and Ys,
which we can think of as the X locations and Y locations
that we were drawing on.
So when we're drawing, so when our pen is down,
we can start sending these X and Y locations
that we are drawing.
The only tricky thing, though, and actually
before we jump into that, and we can
see that if we use these under the motion category,
this X position and Y position block,
this will tell us where our little indicator,
our kind of pen, is on the screen.
So we could just go through, and if we think about the process
before we write this code, we could just go through,
and when the mouse is down, so in other words,
when we're drawing, which we already
have an if statement that is capturing this condition,
we could just start collecting a small segment of line
that we drew, and then we could send it over
to the other people involved.
So let's give this a try.
So actually, before we jump into it this way,
we could make it one step even simpler.
And we could just keep track of what we drew
and then send it over once we're done drawing.
So we can just make some variables.
I'm just going to name them the same thing that we're naming
our field, so X's and Y's.
And when the mouse is down, these X's and Y's
are the list of X coordinates and Y coordinates to draw on,
can just start collecting the current location of your pen.
So in other words, if the mouse is down, we have pen down,
but then we'll also add our current X position
to our list of X positions to draw.
And similarly, add our current Y position to our list of Y's.
Now, like before, we're going to also
need to initialize, of course, these lists of X's and Y's.
So when the green flag is clear, or when the program starts,
set your X's and Y's to an empty list.
Now, you'll notice that I first started putting it
under the when green flag click, but then I
caught myself, because we really want it
when the program starts, which could be when I click
the green flag, or when Cliff clicks the green flag,
and then I just receive the start message.
So now we have this simple first pass, where when we're drawing,
we're recording this list of X's and Y's.
And then as soon as the pen comes up,
then we could just draw or share whatever
we drew in that little batch.
So now we would share this by sending a draw message
to Cliff or to the other roles.
That includes your X's and Y's.
Now, we probably don't want to send this if they're empty.
So we probably just want to make sure
that we actually did draw something,
or else every time we don't have our pen down,
we'll just be sending a bunch of messages.
So we can add another if statement in here
that's checking to see if we have any X's or Y's in the list.
All right.
So we check to see if the length of our X's,
or we could check with the Y's, they should be the same length,
is greater than 0.
And if that's the case, then we're
going to send this draw message to the others in the room.
All right.
So now at this point, when we're drawing,
now, it'll put the pen down and should draw it on our screen.
And then as soon as we stop drawing something,
it should send the drawing that we just made over
to the other people in the room.
And then, of course, we should be
drawing that on our own screen.
So with that, I will kick it over to Cliff
to implement the remote pen, or the pen of the other person
using this whiteboard, that should be then drawing
or handling these draw messages.
So I believe that I have at least a similar version
to what Ryan coded on his end.
As you say, as long as it has the same functionality,
we're good.
But now the thing is, why do I need to create another sprite?
Well, I could handle his messages coming over
in my same sprite, but the effect
would be that we'd be fighting over that sprite.
I would be trying to write, and then messages
would be coming in saying that Brian wants to write there.
And we would probably be bouncing around or struggling
to take control of that sprite.
And that's not what we want.
We actually want a collaborative whiteboard.
So in order to do that, I'm going
to create a new sprite over here.
And I'm going to call this one, let's call it remote pen.
How about that?
And in remote pen, I'm going to then
want to capture the messages that
are coming from the pen that Brian is using
and then draw them on my board.
So I can actually reuse a lot of what I've got here.
So let me just pull this part over.
Oops, am I going to be able to pull over and leave it?
Oh, yeah.
Yeah, there we go.
OK.
OK, so we don't need the start here,
because we're already going to be starting.
But what we do need is to handle the message that's
coming from Brian that he's wanting us to draw.
So when I receive draw, then I've got my x's and y's.
We don't need to set those anymore.
And so I've got my x's and y's.
And what we need to do now is just
And what we need to do now is just to draw them.
And I also didn't need to capture the information,
because presumably, we've already got that information.
But we don't want the forever block,
because we only want to do this for the amount of time
that Brian has data in the payload that he sent us.
So for that reason, we'll use another kind of loop here.
Let's go to get a loop here.
And we'll just repeat for the length of the x's,
because they always come in pairs of x's and y's.
So I can duplicate this here.
And so there we go.
So for the length of the x's, we're going to repeat this.
I'm going to put the pin down.
And then we're going to go to, now, the question is,
where do you want to put the pin down?
If you put the pin down before you get started,
you'll have these kind of jump lines
that go from where you are right now,
or where Brian left off, to where he's drawing.
We don't want to do that.
We want to actually just put the pin down
after we get the initial starting point.
So we probably don't need this now.
So we'll start at length.
We'll repeat this for the length of our iterations
that we get from draw.
And now we just need to do the drawing.
So we'll go to this x and y-coordinate here.
And there.
And then at the end of this, we just take the pin up.
And that's under pin, of course.
It's a different green.
There we go.
And that should take the pin up.
I think that's all we need.
Let's see.
Let's give it a whirl.
Let's give it a try.
All right, so I'm going to actually take these watchers
off, too, which just make it look nice.
All right, so I'm going to hit the green flag.
That should start for both of us.
You can see that messages are coming
through, lots of messages.
We are not drawing on my end yet.
So there are a few problems.
As you can see, we have this little red speech bubble
on Cliff's screen right here.
And that's showing that there are
a lot of messages being sent.
So if we look back at our code, we
can see that if the length of the x's is greater than 0,
we send this draw message.
But we don't actually clear the list of x's.
And we are also not handling the,
we need to iterate through this in a way that
actually handles each item in the list and then clears it.
Yeah, exactly.
So we need to.
There's some problems on both ends, I would say.
Yeah, there are.
But debugging is a natural part of it.
Debugging is good.
All right, so why don't you debug your side first?
So if we look on our side, we can see that we just
need to set the x's and the y's to this empty list.
And that should take care of it.
Now, on Cliff's side, you can see
he's got this big message queue buildup.
He should be able to just right click, I believe,
on the message handler.
Or maybe it's just regular click on the dialog.
Can you click on the little dialog?
I always forget.
There we go.
OK.
You can clear the message queue.
OK.
So now we don't have to worry about actually handling
those thousands of messages.
That's actually a good thing to know,
because that will happen frequently
if you have messages piling up.
And so the way that you saw us clear them,
it's important to understand.
And also, what we see here, then,
is I need to, when I'm getting the length of this list,
I actually need to then iterate through it each item at a time
and then draw it.
So probably, rather than the repeat block,
since I need to actually keep track
of where I am in the iteration, we
should probably use a for loop.
So let's do this.
So for 1 to the length of xs is going to be better.
And then we're going to have to grab from our list the item
that corresponds here.
So we can duplicate this.
And then we're going to want to go here to each of these
in turn.
Make sure we get the x and the y in the right place.
There we go.
And then we put the pin down here so that we start writing.
And at the end of it, we take the pin up.
All right.
So we'll give it another try.
See if that works better.
All right.
So now I draw something.
And as soon as I'm done drawing, it draws on my side.
And no messages are piling up either.
So I think we cleared those two bugs.
That's fantastic.
Now, there is a lot more that you
can do with this distributive whiteboard.
On my end, it should be the case that if I'm drawing,
let's see.
So we do need to fix that bug on this side.
Yeah, we have not fixed it.
And so I'm piling up those messages here.
So that might be something that we could do together.
Or you could, again, look at this code
and see where you need to fix that.
Basically, you need to make sure that you're
emptying these lists at a certain point.
Otherwise, your lists are just going to increase in size.
And you're just going to continually send these
messages.
So we need to empty our lists.
And there are other things that you
can do to maximize performance.
We're not going to probably get into it in this video.
But one thing that you could do, for example,
is send over lists of a certain size
so that you don't send each particular point
as a single item over the internet.
Because, again, there's a lot of latency involved.
Your messages may get piled up.
It might be better to send reliable chunks.
And the size of those chunks may depend
on what your network conditions are like.
So that's something you might want to experiment with.
But Brian, any other final thoughts before we wind up?
OK, so basically, one extension to this
is that currently, you can see that we're only
sending the drawings once they're complete.
So it might be nice to actually send drawings
while they're being drawn so that I don't finish my drawing
and then it shows up.
You could actually see me in the process of drawing
while I'm drawing it.
So if we wanted to do something like this,
we could actually start breaking the drawing into smaller chunks
and not waiting until the pen has come up
before we send it.
There are other nice features that
might be nice to add, like selecting your pen color
and, of course, synchronizing this across both devices.
Similarly, clearing the screen and synchronizing that as well
would be another kind of feature that would be nice to have.
All right, but I think we'll leave
that to you as an exercise.
We'll put some of that information in the comments
if you want to tackle those and maybe look at projects
where those features are implemented.
But for now, at least you get the idea
of how you can work collaboratively with two
sprites to develop a shared whiteboard.
And you also saw, by way of our errors,
what happens when something goes wrong in message passing
and how to both diagnose that error
and then to clear it from your program
so you can continue programming.
For sure.
So thanks, everyone, for joining us.
And we'll see you in our next video.
</p>
  

    <h2>20. simple-lists</h2>
    <p>Hi everyone. Welcome back to our series on programming for a networked world.
Today we're talking about lists. We all have experience making lists.
Every day I add items to my list of things to do.
For example, I added a reminder to make a video today about lists.
So, now I can cross that item off my to-do list.
Lists in Nextbox function in a similar fashion.
Nextbox allows programmers to create lists, add items to lists,
find items on lists, and remove items from lists.
Lists also help programmers to manage related items of information.
Ready to recreate your virtual to-do list in Nextbox?
Let's make some lists together.
Lists are a fundamental data structure in Nextbox.
Lists come in all shapes and sizes, but we'll begin by covering the simplest
form of list. That is a one-dimensional list.
A one-dimensional list is a fancy name for a list that just contains a
sequence of things like numbers, strings, sprites, etc.
We can create a list of this simple sort by
going over to the variable palette and pulling out the list block.
In that input slot we can just put, let's see,
script a video. And if we want to add something else I can
expand this block and say
film a video. If you click on the list block now
you'll notice that we have a pop-up. It gives us the items in the list back
next to the numbers 1 and 2. So, as you can imagine,
those are the first and second items in the list.
In some languages the first item in the list is indexed as 0
and the second item as 1. In Nextbox we follow the more intuitive system
of numbering the first item as 1 and the second as 2
and so on and so forth. But that is called the
index of the item. It gives you a number by which you can look up that item
in the list. Adding items to our list by just expanding the list block
and adding them manually will get boring over time.
We'd rather have our program do this for us, right? Not just do it by hand.
Fortunately we can add new items programmatically as well.
So, for instance, we can add a third item,
say like edit video to our list, using the add to list block.
We'll type in the item that we want to add to our list and then we'll bring
down the list and hopefully it'll all work. Let's take a
look. So the four blocks that you see down here
are command blocks that mutate lists. That is, they'll change the information
contained in a list. And the four blocks, as you can see, are
add, delete, insert, and replace. We're going to try
all four of them, but let's start with the add block.
So I can bring over the add block here and
this little slot here with the alternating red and white
is the slot for the list. And then I can add
a thing. Let's give it a name. Let's say
produce video. So I can type that in, produce
video, and then I can click on it. Ah, but nothing happened.
Why didn't anything happen? Well, this is a command block
and it mutated the list, but it didn't show us the result.
So in order for us to see what the result is, we need to create a variable
first to contain our list. So I will create a variable called to do.
Let's go up to the top here and make a variable.
And I'll call the variable to do. There we go.
And now what I'm going to do is I'm going to bring over this set block
and I'm going to drop this list in and I'll call it to do.
And now I can take that reference here and put it down here. So you can see
if I bring up the watcher now, after I set it,
I've got two items in my list. But when I add
another item, it will appear as the third item in the list.
And there you go. So I've just mutated the list by adding a third
item to it. So now the list contains three items.
So let's try our hand at the three other blocks that mutate lists.
The delete block, the replace block, and the insert block. These blocks all
work with the index of the items in the list.
To use them, you need to know where the item you want to remove or insert or
replace falls in the list. So for example, if I have finished the
script for the video, I should delete that from my to-do list.
I can use the delete block to do that. And since I know that that was the first
item on my list, it's very easy to get the index. It's
just index one. So let's try that. I'll go over here
and bring in delete. Delete item one of. Let's duplicate this to-do list.
And I'll bring it down here. Put it in the slot. Delete item one.
You can see I've finished now scripting the video.
The second thing that I need to do is let's add a third thing. I want to produce
the video. I've got that. So let's say upload it to YouTube. So let's say
upload video to YouTube. How about that? Spell that correctly.
Okay, so I'm going to add that, but I don't want to add it as my first item, so
that's not the right place to put it. I'm going to insert it now.
If I can get that text again so I don't have to retype it all.
And put it down here. And I'm going to insert that as number
three. So I'll put it at the end of the list. So there we go.
Oh, yes, if you don't put the list in, you will see that error message.
So I'll put the list in and insert it. And there it is. Upload video.
Okay, oh, misspelled. So I misspelled it. That's actually helpful because now I
want to replace it with something that's spelled correctly.
So let's do that. So I'm going to take this
replace item, and I want to replace number three.
And I want to use the same list. So I'll duplicate the list here.
Put it in. And again, I'll click and copy this. But before I change it, I want to
change this O to a P so it's spelled correctly. So you see we
have UOLOAD. And if I click on this now,
oh, don't need it connected with another block. If I click on this now,
you can see that it replaced it to upload video.
So with the combination of these four blocks,
you can make lists contain any type of information you want,
and you can keep it updated in real time as information
in the program changes. So keeping track of information using lists is an
extremely common task in Nest Blocks. Practically every application you write
will involve the use of lists. Many times it will involve the use of
multiple lists. In this video, we saw how to create a
one-dimensional list and mutate it by adding, deleting,
inserting, and changing items. But lists can do more than store your
to-do items. In the next video, we'll explore how to
use two-dimensional lists to store and explore tabular information.
But that's it for today. If you want to do something for extra credit,
then try building your own to-do list in Nest Blocks.
And don't forget to add watch the next video in this series
to that to-do list. Thanks very much, and see you next time.
</p>
  

    <h2>21. structured-data</h2>
    <p>Hi everyone. Welcome back to Programming for a Network World. Today we're going to
be talking about a way to make it easier to work with lists. So sometimes you get
really long lists of lists and they become difficult to manage. You're saying
index 1 of this list and index 2 of that list, trying to get down to the
information that you want to retrieve. In this video we're going to be talking
about ways to find information in lists by their keys. That should make it a lot
easier to keep track of the items in your list. Ready to find information with
the right key? All right, let's get started.
So let's begin by opening the particular library that we need to use, which is
called the Structured Data Library. So if I go over here to Libraries and it's
down here and I click on that, see I've got a list of libraries that I can
import. So we'll type Structured Data and I'm going to open that and it imports
those blocks. And if you look under the custom blocks you'll see that they're
right here in this list that I can use. Okay, so it gives us several blocks. I
pull them over. We've got a value, set value, delete, and we won't worry about
the error block for now. Okay, so the difference between these blocks and
your index 1 of blocks or index n of blocks is that they will be able to find
information by a key. So it's typical that you might have information that
comes in the form of key value pairs. And it will look like this. Let's just make a
simple list together. So I'll make two slots here and then I'm going to put
inside of the slot another set of lists here like this and open those up. There
we go. Okay, and so when you have a structure like this, the first item will
be your key. So we might say like course. And then the second item will be your
value. So we might say like programming. And then in the second list we could do
something equivalent. So the first will be, let's say, date and the second will
be 2022. Now when we look at that, we've got a nice list of lists. If you
normally wanted to get information from this, you would go to get the item 1 or
item n of block and then you could drop this in here. And you could say, okay, let
me get item 1, which is going to give you course and programming. And then you
might want to say, oh, but I just want to get the value of that. So then you have
to get another one of these blocks and get 2 here for the value. And this
should give you programming. Okay, so that's fine and it works well when you
have a kind of simple list of lists. But the thing is that it's easy to lose
track of where that information is. Should it be indexing to item 2, indexing
to item 1. It's easy to forget what that number should be and then you'll get the
wrong piece of information out. So that's what the structured data library
aims to solve. If you've got lists in this format, then you can use the
structured data library to retrieve the particular values of those key value
pairs by name. So for example, let's assign, we'll make a variable here and
we're going to call this course information. So we can imagine it's like
a course management system that we're doing. So let's go to the variables tab
and we'll set a variable here. I'm going to set this course information to this
particular list. We'll get rid of the item 1 of and item 2 of. Okay, bring that
up here. So we've got the list of lists and I'm setting it to the variable
course information. Okay, so now that we've got this variable, let's bring that
down, course information, and we'll drop it into this slot here. And let's say
that I want to see the course that I'm taking. Well, I can just type in course
for the key. I've got to set it first. Rookie mistake, didn't set the value of
the variable to the list. So you can see that we've got course information there.
So let's try to get the value out. So in this case, I've got the value course and
if I click on it again, I get programming. Okay, so that's the way that it's
intended to work once you set the value. Now, if I want to get the date out, I can
do the same thing. Just type in date. I think you can see that that's a much
easier way to approach these types of key value pairs inside of a list. And you
can also use the same library to set information. So for example, I can set the
value of the course. It's actually not programming. It's programming for a
network world. So programming for a networked world. And if I click on that,
you'll see that now when I go down and bring out the value of course
information, let's say a course in course information, it's now programming for a
networked world. So I can set the value that way and if I wanted to, I could also
delete that key. And now if I go down here, it should return an error because
it couldn't find any key with that or any value under that key. Okay, so that's
the way the library works. Let me show you an example from the real world about
how you might use it. So let's go and get some data from the Internet. We'll go to
our network tab and let's pull over our block here. We're going to call one of
our RPCs and I'm going to get this course information out of the way there.
Okay, I'm going to call one of the RPCs. I'm going to go to the history. We'll go
to the New York Public Library. Let's search and let's search for the term
Vanderbilt. Let's see what we get. We'll get 10 results per page and we'll just do one
page of results. So when you click on this, you get this kind of typical list
of lists and it's, at least in this view, it's got so much embedded information
that it's hard to read. You can't actually read it without clicking into
it. Now we could still take that approach of going to get the item one of and
we'll take a look at that, sort of see what information came back, and we see
that for item one we have four key value pairs, the UUID and the item ID, but we
also have a title and a date digitized. I think what might be most interesting is
for us to just look at the titles of the information that came back. So let's do
that. Now again, like we could iterate through all this with, you know, the item
blocks, but let's not do it that way. Let's use our new library. And so let's
go down to the for each block and pull that over. And the for each block will
loop through this list and each time assign that item to one of the items in
the list. So that's a helpful helper block to have. We'll just drop our RPC
there. So now that we're going to be iterating through each item in the list,
then we can do something with what's inside. And so here we're going to take
this value of and we'll have Ada say it. So I'll bring over the looks. Let's see
here, say hello, and we'll replace hello with the value. Now the value should be
title of the item and she'll say it for two seconds. Now if this works as we
expect, the RPC will go out and get that data, 10 items in the New York Public
Library about Vanderbilt, and then it will go through each one and pull out
the title. And we don't need to remember where the title fell in that list of key
value pairs. We can just say we want the title from each of those items. And here
we go. So now you're seeing that's two items have the same title, but there's a
different title. Knox 1909, number 665, the Breakers, New York City, Cornelius
Vanderbilt, the Commodore, and maybe one without a title, the Vanderbilt Hotel. And
we're at the end of our list. So you can see there that in terms of readable code,
that's a lot easier to read and understand what's going on, not only for
yourself, but for someone else that might want to use your program in the future.
All right, that was our short introduction to the structured data
block. Thank you for joining me, and I look forward to seeing you in our next
video.
</p>
  

    <h2>22. twitter-filter</h2>
    <p>Welcome back, everyone, to Programming for a Network
World.
We're going to be continuing our exploration
of textual analysis.
But this week, we're going to explore
how to get a feed from Twitter and then
to screen out any bad words that might be in that feed.
So ready to develop your own parental filter in NetBlocks?
Let's get going.
OK, so here's our project.
As I said, we're going to reach out and get tweets from Twitter
on a particular topic.
And then we're going to develop a filter for those tweets that
will examine any tweets that have insulting, negative,
foul language, however you want to put it.
And we're going to try to filter those out.
And we're also going to develop a kind of sensitivity
level that you can select to decide how carefully you want
it to be filtered out or whether you
might be willing to risk a few bad words coming through.
So let's get started by just bringing over our network tools
here.
So I'm going to go over to the call cloud variables.
That's not what I want.
I want Twitter, which is down here at the bottom.
OK.
And let's just see how this works.
So we're going to do a search.
And you see here that there's a keyword and account.
So let's start.
I'm going to choose a kind of homegrown example here.
I thought kind of what I should use
to illustrate this, some kind of contested topic.
And I thought, OK, well, we just released
a new logo at Vanderbilt. Some people really love the logo.
Some people really don't like the logo.
So we're going to look for Vanderbilt logo
and see what people are tweeting about the logo.
So here we go.
I'm sure that everybody listening to this
after they see it will have their own opinion.
Send a tweet about it and get included in this list.
OK, so Vanderbilt logo.
And let's just get a count of 20.
And you see here that what comes back are tweets.
And good to see Vanderbilt golf.
Well, you have to kind of pull this out.
Vanderbilt introduces a new logo.
So the old logo was unique.
Does Vanderbilt have a new logo?
So a lot of this is kind of neutral.
But probably some people in there have some negative takes.
And hopefully, people have positive takes, too.
Now, you notice when you look at this
that the tweets are coming through,
but there's some metadata that's included on the front end.
And we don't really want that because we
want to send just the content of the tweet
to our natural language processing toolkit.
And so what we need to do first is work with these tweets
to split them up a little bit and take off that metadata
and also take off the handle of the person that
is sending the tweet and just get
the content of the tweet itself.
So let's start by doing that.
In order to do that, we're going to create some variables.
And so I'm going to bring over some script variables
that we'll start using.
And let's just set this one to get tweets.
And then we'll set tweets over here to call tweets.
So that'll get our tweets.
So that's good.
And then let's get the next one where
we tokenize those tweets and we split them by word.
And so that will help us then to be
able to filter out the parts of the tweet
that we don't want to send for NLP examination.
So we'll call this tokens.
And here I'm going to set tokens.
Maybe I'll move the stage over a little bit
so we can see this better.
I'll set tokens here to let's get this operator here split.
We're going to split tokens.
But we actually need to map this,
I guess, because we're dealing not just one set,
but a whole bunch of tokens.
So let's get our map block out there.
And so we're going to map this split here.
And we'll put nothing in there.
And we're going to do it by word.
Oops, this is the wrong place.
This needs to go in here.
And the list goes over here.
Now, let's start seeing if we're making
the progress we'd like.
So what we'll need to do is go to Control here and find
our report block.
And we'll just report those tokens,
make sure that we're getting back what we expect.
So let's run this.
And no, indeed, we're not.
So, oh, I put in tokens.
This needs to be tweets.
There we go.
All right, let's see if this works now.
OK, so you can see now that everything that's
considered a word, and that could be the beginning
of the parentheses here.
And these are the handles all sorted out.
It's pretty uniform.
So we can see that all we really need to do,
then, is we want to get rid of 1, 2, 3, 4, 5, 6,
the first six columns.
And so how do we get rid of those columns?
Well, we can take another map.
And we could just say that we want column 7
to the end of that list.
So we'll just drop the first six by mapping
that we want only the content.
So I'm going to call these contents.
And so here's how we'll do this.
We're going to set contents to a map.
Let's get this over here.
And in the map, we're going to say item.
Let's see, let's take, yeah, item here.
Now, we don't want 1, or we can't just say 8 or whatever,
because we actually need more than one item.
So we can drop in here more than one.
So we want items number 7.
And then to 10, well, the thing is,
we don't know where the list actually ends.
So we're going to grab length of list.
And the nice thing about this map
is these empty slots that we leave
are going to be filled in with the items from the list.
So we'll know, for example, if there are particular tweets
that are longer than others, that we'll
go all the way to the end and capture all the content.
So then we're going to use here tokens as what we map over.
Let's see if this works by returning the contents now.
And you can see now that we have a smaller list of lists.
And it's just listing the content.
It's actually now removed those first seven of our columns
so that we just have the content,
which is what we wanted.
So we're making progress here.
But now we need to compose it back together with a join.
OK, so how do we do that?
We're going to use our combine block.
And let's make another variable here.
So maybe we'll call this combined.
OK, so let's then set combined here.
And as I say, we'll go out and get our combine block.
Now, combine, as we know, it's a little bit different
in its style.
It's going to take this list.
And then it's going to create all the elements in the list
will be joined together using some kind of operator.
And the operator needs to have two slots.
It's basically a slot for how it's
going to operate with each element in the list.
And then we'll continue to process the list.
So it's two slots rather than just one.
So let's go over here.
And the two slots that we want are going to be under join.
And we want to join things with a space in between.
So that's what we're going to do.
If I can find join here.
All right, so I'm going to do it like this.
And we're going to join, leave an empty slot there,
put a space in the middle.
And then we'll put another slot there.
OK, so that's how we're going to combine it.
Now, the thing is, it's the same problem
we had before, which is we don't want to just combine
one row this way.
We want to combine all the rows this way.
So we need to have a map.
And this could be a little confusing.
Sometimes when you use two of these higher order functions
together, it looks a little complicated.
But it's the same principle.
We're just going to apply this to every row.
And that should take every single row
that has each of those columns, no matter
how many columns there are, and combine it into a single string
or just a textual element.
So we just need to map this now over words,
or I guess in this case, combined.
And then we want to report combined.
So let's see here if that works for us.
And it did not yet.
So where did we go wrong here?
Oh, oh, oh, oh.
I'm getting ahead of myself.
It's the second time I've done it.
We want to do it over contents.
The data should be flowing from top to bottom.
So each time that we create a new variable,
that goes in as the input.
And then it's set to another variable that's,
in a sense, the output.
So let's try that again.
OK, and there we go.
So now, those are the tweets.
But they're the tweets without the metadata.
They're the tweets without the indication
of how much they've been retweeted
and without the indication of who sent them.
There could be scenarios in which you
want to keep that information and then put it back
into a table and just have the columns maybe
have three parts, metadata, who sent the tweet,
and the content of the tweet.
But for this project, we don't actually need that.
So I'm just going to stay with this
to keep it on the simple side.
So that's the list processing that we
have to do to get our tweets.
Now, the next stage here is we want
to think about how to go through each of these tweets
and then examine to see whether they contain language that
should be filtered out.
So the way we're going to do that is,
let's go back over to the network.
And we'll bring another call block over.
And let's just see how this works.
We're going to go back to the service
here under Language, Parallel Dots.
And you can see here that we've got getAbuse,
getEmotion, getIntent.
We're going to go with getAbuse.
And let's just test this.
I like the new logo.
So this should not be abusive.
Let's call that.
And you can see here that it gives a very low probability
that that's abusive, basically almost none.
There's also an indication of whether it's hate speech.
And then there's a high probability that it's neither.
Now, if I change this and I maybe said, I detest,
now, is it abuse?
It's just an opinion, really.
But it should register higher on an abuse scale.
Only a little bit.
So let's see.
I detest the new logo.
Didn't really count as abuse.
But how about, I detest the designers of the logo.
Again, pretty low.
So you see that it'll pass a lot of things through.
I feel bad typing all this stuff.
That's a lot closer to abusive.
So you see here, I hate next blocks.
I hope you don't feel that way.
But if you did, we'd just screen you out.
So there you go.
That's abusive, according to our natural language processing
unit.
So here's the thing.
We're going to use that.
And we're going to plug this in to the tool
here that we've built, this set of blocks.
And we're just going to process each of these tweets.
And then we're going to respond appropriately.
So let's take a, under variables here,
we're going to take this block called forEach.
Let's go ahead and grab it.
There we go.
Pull this off.
And so we're going to put in the forEach here
that for each item in, let's say, content, actually
combined, sorry, there we go, for each item in combined.
And we could make this a little bit clearer
by calling it forEachTweetInCombined.
Let's do something.
And what we want to do is use an if else.
So we will call parallelDots and ask if it's abusive.
And then if it is, we'll register that it is.
If not, we'll pass it through.
So we want to, let's just take this here
and see if we can set a threshold for being abusive.
So if parallelDots comes back and says
the threshold is less than a certain amount,
let's say 0.05, then we'll say that it's not abusive.
If it's higher than that, then we'll say that it is.
Maybe let's just try 0.5 for now.
So now we'll just put in here, just for a moment,
something to kind of stub in what we want to do.
So I'm going to say, I don't really
need the report block anymore.
Get that out of there.
So we want to say not abusive or abusive.
Actually, it's this tweet here that goes in.
So that's going to contain each line.
We're going to call parallelDots.
We're going to get that information.
And then we're going to see if it meets the threshold.
And if it does, then it will fall into the abusive.
If it goes under, it'll be not abusive.
Now, we can just run this.
And let's just run it for maybe three tweets
just to check out what it says, because we
want to build this into a larger program.
But I just want to test it to see if it works.
And non-abusive, non-abusive, non-abusive.
Let's just take a look to see, for example,
what is actually coming back in terms of what
parallelDots is telling us.
So one way we could do that is we
could do the call above here.
So we could just set another variable.
Let's do abuse score.
So it gives more insight into actually
what the scores are that are coming back.
And then let's, for each tweet, we want to set that here first.
Let's get the variable set.
Oops.
OK.
And this should be inside the forEach.
OK.
So we're going to set this abuse score
to calling for this tweet.
And then, oh, I think here's the problem.
We need to actually drill into that abuse score a little bit
in order to get the actual number.
We're not actually getting to the right number,
which is why this is not working.
OK.
So that's probably what our mistake is right here.
So remember, when we call parallelDots and we say,
let's just give it the word abuse,
then it has a score here.
So we need to actually get this score.
And what we're passing in is this list of lists.
And that's why it's not working.
So let's go over here to get that structured data library.
OK.
So we're going to get the structured data library.
And let's go down and start pulling pieces out of this.
So here, I think what we want to get is abusive.
And then let's pass in this tweet.
And then we should get a score.
And that's giving us an actual score.
So that's what we needed.
And that's fine.
So let's bring this back in here.
And that will give us the score.
And there's our tweet that goes in.
And then we can say, if the abuse score is less than 0.1,
say not abusive otherwise.
So now we can test it again.
Let's bring this over here so it's
a little bit easier to read.
And let's give it another shot.
Not abusive.
Not abusive.
Again, abusive.
OK.
So now we know abusive.
OK.
So we've set a threshold.
And you can see that it's flagging
certain of our tweets as abusive and others as non-abusive.
So now, in principle, we've got everything working.
What we need to do is just turn this
into something that's got a better user interface.
So what we want to do now is let's start by, well,
always good to start by putting a hat block at the top.
So we'll do that.
And then let's ask a question at the beginning.
I think that we may want to switch Ada out
for a different costume here.
Let's just go to our turtle.
And that will be, I think, easier to use.
OK.
So now we want to ask a question.
So that is going to be under Sensing right here.
And the question we want to ask is, what topic on Twitter
would you like to search?
OK.
And then we'll wait.
Now, so here, we're going to take the answer
and plug it in there.
So that will allow folks to put in whatever topic
they'd like to have.
And then we also want, later on, to ask
for the level of sensitivity here.
So after we get through looking up
the contents of that topic on Twitter
and doing the list processing, then
we want to think about what level of sensitivity.
What is the sensitivity?
What level of sensitivity do you want?
And we'll set a score between 1 to 100.
OK.
Now, here, we're going to use the answer again,
because now it's going to be set to the answer for this question.
And when we set this abusive score here,
let's set the value of that abusive score.
It comes back with a number that's up to 1,
so like 0.99 or something at the highest level.
So if we want to think about the sensitivity level,
then we need to take that answer, 1 to 100,
and just divide it the same way by 100.
Here we go.
And now we can use this here to set our level.
So that will set the level.
Excuse me.
And then we'll be able to see, for example,
based on our answer, we'll let people
set their own sort of comfort level
with seeing texts come through.
Now, the last thing that we want to do
is just write on the screen.
And we've seen this before in the Sentimental Writer,
but I want to take the time to actually go through
and do it this time.
So let's just start here by clearing the screen.
So we'll put a clear up at the top.
And then let's set a pen color.
This is all just to make sure that we can write in a nice way.
So we'll set the default pen color to a nice blue.
Then I think that what we'll do is we'll put
the pen in the right place.
So let's go, and you kind of have to experiment with this
just to kind of figure out where you want to start.
On our screen, I think negative 220 and then the y value of 150
should put us in the right place.
We can sort of test where that would be just
by dropping this down here.
You can see that it puts us up in this corner.
Maybe it's a little bit too far over,
so let's say negative 210, something like that.
That looks good.
So that's where we'll start writing, and with the color
blue.
So that's good.
Now, we need to do the writing part, which is actually
down here.
So we'll take out these stubs that we put in, the say blocks.
And so this one is going to be if something's not abusive.
So basically, what we want to do is write the item to the screen,
and we can do that with pen here.
Let's go down to write.
And we're going to make it size 10,
because even at that size, the whole tweet
won't fit on screen.
There are some libraries that you
can use that we can provide to wrap the writing on the screen,
but we're not going to go that far in this
because our goal here is not to show you
how to build those kind of libraries.
It's just to help you to see what
the tweets are that are coming through
and what ones are getting filtered out.
So what we want to write, though,
is the tweet, content of the tweet.
So there we go.
And that's good.
Now, the only thing that we need to do is just make sure
that we're in the right place here.
So at the end of our writing, we want to go back to,
let's see, set x.
x is going to be stable, because x is always
going to be just starting on this left-hand side.
So I think we said that was negative 210, right?
And then the y value is going to change.
So we're going to take this change block here.
We're going to change the y value every time.
And since we want to be going down on the screen,
we're not going to change it positively.
That would move it up.
We're going to change it negatively to move it down.
So that's good.
And we can use basically the set of blocks
here with a little tweak for the abusive part.
The tweak is we're going to change the pen color
so that we're writing in a different color
to indicate that we've filtered something out.
And we're also not going to pass through the tweet,
because that would kind of defeat the purpose.
We're just going to write in redacted.
Put censored.
You could put not shown, whatever you like to say.
So redacted.
And let's change the pen color.
So let's go over here, change the pen color,
and let's put it in maybe a lighter red, something
like that.
And then we need to set the pen color back.
And let me duplicate this up here.
Oh, I got the whole thing.
That's more than I needed, but it's all right.
So let's drag this down and set the pen color back.
I think that should be it.
Shall we give it a shot?
Let's try this.
So I'm going to get the screen a little bit bigger
so we can see what's going on here.
We don't need to watch the code as much.
And let's hit that green flag.
So what topic would you like to search on Twitter?
And we're going to go for the Vanderbilt logo.
And what's sensitivity?
Let's just go for, like, 30.
We're going to be pretty sensitive.
So we've got some positive ones, and then we've
got some ones that were redacted.
And you can see that the positive ones are
indeed positive.
Good to see Vanderbilt golf coaches and players
wearing the correct logo.
New logo didn't catch up.
Introduce a new logo.
Fans see the beauty.
Logo battle, who you got.
So there were two comments that were taken out
based on our sensitivity level.
So if we run this again and we set a very low sensitivity
level, let's just set it at a 1, we
should see probably even more redactions.
Oh, I need to put Vanderbilt logo here.
And then let's set a 1.
We got one more redaction.
And then if we ran this again and we
set our sensitivity level as 99, we only had one item redacted.
So you can see that our sensitivity
to what's coming through our filter, we can easily adjust.
And that's all thanks to the natural language processing
that's built into Nest Blocks.
So that's the end of our segment for today.
I look forward to seeing you in our next video.
</p>
  

    <h2>23. two-dimensional-lists</h2>
    <p>Hi everyone, welcome back to our series on programming for a networked world.
In this video, we are covering two-dimensional lists.
The term two-dimensional list is a formal way of talking about a very common data structure
that we may alternatively call a list of lists, a matrix, a table, or a spreadsheet.
Keeping track of data using columns and rows proves efficient in many scenarios.
Netsblocks also optimizes the display of two-dimensional lists to make it easier for you to read and
edit them.
Ready to expand your knowledge of lists into the second dimension?
Let's get started.
What is a two-dimensional list?
In the last video, we talked about one-dimensional lists.
As you recall, a one-dimensional list is just an ordered sequence of items.
So my grocery list is a one-dimensional list.
I need to buy eggs, milk, tea, and so on.
But I also mentioned that lists can hold data beyond strings and numbers.
A list can contain sprites, for instance, or blocks.
But what happens if you put a list inside of a list?
Now you have a two-dimensional list.
How might a list of lists prove valuable in a program?
Let's imagine a scenario where you are programming for people who are speaking different languages,
and you wanted Ada to interact with them in their own languages.
You might want to keep a table of equivalent phrases from those different languages.
So for instance, I might want to create a list of greetings to use in my program.
My English greeting would be Hello, my Dutch greeting would be Guten Tag, my German greeting
would be Guten Tag, and my Chinese greeting might be Ni Hao.
And I would want to put all those greetings into a list.
And just so we had an equivalent way to say goodbye, I'd want to do the same for saying
goodbye in Chinese, Dutch, French, German, etc.
So how can we keep all that information together?
The answer is simple.
We just have to put both lists inside of a list.
And that will make a two-dimensional list.
And then we'll see, as we do that, that it forms what looks like a table in NetsBlocks.
So let's get started and see how that works.
So I'm going to grab a list here and bring it over.
And now I'm going to put on this list a series of languages we want to use.
So let's say Chinese, and Dutch, and French, and German, and English, let's not forget
English.
OK, so that's a good list.
And then let's put the greetings that we want for each of these.
So I'm going to open up slots now for each one of these languages to put in the way that
we would like to greet people.
So let's say in Chinese, that's Ni Hao.
And then in Dutch, Guten Tag.
And in German, oh, it's in French, Bonjour.
And in German, Guten Tag.
And in English, hello.
Now let's do the same thing with another list where we say our goodbyes.
OK, whoops, keep clicking on it when I don't mean to, just when I get those arrows.
OK, so Chinese, that would be Zai Jian.
And in Dutch, we'll say Tot Ziens.
And in French, Au Revoir.
And in German, let's say Tschüss.
Oops, there we go.
And in English, finally, we'll just say, goodbye.
OK, so now we have these three lists, but we want to put them together so that they're
just a single data structure.
And here's where the cool thing happens with a two-dimensional list.
So I'm going to take a list, and I'm going to open three slots.
And I'm going to move the first list into the first slot, the second list into the second
slot, and I'm going to move the third list into the third slot here.
Now this is a two-dimensional list.
You can see that it's a list of lists.
And when I click on it, it displays like a table.
So you can see here that this is the column with the Chinese greetings and the Dutch greetings,
the French greetings, the German greetings, and the English greetings.
Now if you want to extract any information from this, how would you do that?
OK, so you would use the same item of, and then you would drop this list of lists into
it.
But now what is item one going to get us?
And here's where we have to learn to think about how lists of lists are composed.
So if we ask for item one of this list, it's going to return us the first list.
There we go, Chinese, Dutch, French, and German.
So if we actually wanted to get item one of that list, then we'd put item one around
this again like this, item one of, like that.
And then we get Chinese, OK?
And so if we wanted to, for example, have bonjour, then we'd have to go to, can you
guess it, item two, so that's the second list right here, and then we want to get item three
from that list.
And there's bonjour.
So when you're thinking about it, make sure when you're indexing into these lists that
you index first into the lists that you want, and then subsequently into the item in the
list that's returned.
So thinking about this, you think about the list that you want first, and then the item
in that list.
And if you have more deeply nested lists, it's the same process.
You keep drilling down to the list that you want until you finally are able to pull out
an item from the list that you extract.
Now that we've seen how to do this, let's go ahead and build the program that we had
in mind.
So the program that I want to do is, I want to have Ada here greet us in our own language.
How should we do that?
So I'm going to start a program with when clicked, it's always a good starting point,
and then I'm going to create some variables.
Let's create script variables here, and I'm going to name the first one language, and
then I'm going to name the second one language selection.
Now that I have those variables, I want to set the languages, or the, I guess I'll call
this languages just to be clear.
I'm going to set the languages to our list of lists.
And then I want Ada to ask us what language we prefer her to speak in.
So I'll bring this down here for this ask block, and I'm going to say, what language
do you speak?
I guess we have to start off with English because there is no neutral language obviously.
So we'll start with English, and then we'll say, what language do you speak?
And remember that the answer will come in the form of this answer block.
Okay.
Then we want to set the language here.
We want to set the language selection, and here's what we have to think about.
We want to set it to the index of the response in the first list.
So we know the first list contains all the languages that we have.
So we have a block down here that says the index of, so we want to look up where this
answer block appears, where this answer appears in our first list.
And so we need to know that, but we also have to extract that first list.
We can't just give it the list of lists.
We need to get the first list in the list of lists like this.
So now we're going to be asking, okay, for the language that you responded, what language
is that in our list of lists?
So basically, what column is it?
And then by identifying that column, we'll know in the future where to draw the equivalent
language forms for Ada's responses.
So we'll now just do the second part.
Let's just do a simple hello, goodbye.
So Ada will say hello, and then Ada will say goodbye.
So I'll go to looks, and I'm going to bring over this hello block, and we'll use it twice.
But the first time, we're going to index into the list here, and I'm going to get item,
and I'm going to use language selection, because that's what we assigned here.
So we want item, language selection, and that's going to give us the index that we need of,
and we know that this particular row has all of the hellos, forms of saying hello in different
languages, so we want that with our languages.
And then we can duplicate this block, put it here, and we know the third row has all
the forms of goodbye.
So now I can drop this into here, and into here, and let's see if it works.
So I'll click on this, and Ada says, what language do you speak?
Let's start off with saying that we speak Chinese.
Aha.
I've got a mistake here.
Let's see what's going on.
Index of answer in item one of languages, oh, right, this should be languages, not language
selection.
There we go.
All right.
So let's try that again.
Got to use the right list.
Click on this, and we're going to say Chinese, and then Ada responds, ni hao, zai jian.
Let's try it again with, let's say German.
So we'll say German, speak German, guten tag, and tschuess.
Okay, just to test that it works with English too, let's try English, hello, goodbye.
Okay, just one more thing I'd like to show you.
So if you want to change your representation of a list of lists from a table like this
one into an actual list of lists representation, you can click on this and say list view, and
then your view will look like this.
You'll see that it's actually composed now of a list of lists.
You see the three lists within another list.
Most people prefer to see it as a table, but when you get multiply embedded lists, multidimensional
lists, three or four dimensions, then you'll need to look at that list of lists view.
The tricky thing when retrieving items from lists of lists is that you work from the outermost
list towards the innermost list, but your item of list block winds up getting stacked
in reverse order.
So the outermost block will give you the result from the innermost list, and so you kind of
need to think backwards from the inside out.
It's actually not different from any other stack of blocks and nets blocks which give
you values that you can then compute in other expressions.
And don't worry if you get mixed up from time to time about what list you're working with.
So do professional programmers.
Just try varying that index of, and you'll see eventually you'll get to the right item
in your list.
All right, so let's wrap up this video here.
In this video, you learned how to create two-dimensional lists in nets blocks and to explore those
lists in both tabular and list form.
You also learned how to index into two-dimensional lists to retrieve items of information.
And you built a program that demonstrates the utility of making lists of lists for tasks
like internationalization.
In the next video, we'll experiment with the call block to make lists and tables.
See you in the next video.
</p>
  

    <h2>24. variable-scope</h2>
    <p>Hi everyone. Welcome back to our series on programming for a networked world.
Today's topic is variable scope. What is scope?
We use the term scope in ordinary language to talk about what is relevant to an undertaking
and what falls outside of its ambit.
Perhaps you've been in a conversation about a project and someone says,
that's out of scope. In other words, that idea does not fall within the parameters
of what we've agreed to work on together.
Scope in programming languages is a similar concept.
When you create a variable, you should think about which parts of your program
need to have access to that information and which do not.
By defining the scope of your variable, you keep information restricted to its relevant context.
In general, it's better to limit the scope of your variables
so that different parts of your program avoid tripping over one another.
Ready to bind values to variables? Let's get going.
Let's start with the easiest case, creating a global variable.
This is a variable that every block and every sprite, including the stage, has access to.
So how do we do that? We'll click on this make a variable block,
and we're going to type the name of the variable, namely greeting.
And we'll sign it for all sprites. So I'll say OK.
And there we go, we've got greeting here.
And you notice here that it appears in our variable palette.
And there's a checkbox next to it. And if you click the checkbox,
it will disappear from the stage.
If it's checked, it will show the variable name and its current value.
Now, how do we set the variable so that we could have Ada say hello to us?
We bring over this set block. And here we drop down,
and we can see that we have this global variable in the drop-down list called greeting.
And we assign it a value.
So we'll put hello, world right here, like that.
And we'll click it, and it'll be set.
And you can see now that on the screen right here,
hello world is set as the value of greeting.
Now, if we want Ada to say hello to us,
we'll go up to looks, and we'll click on say hello for two seconds.
But instead of just saying hello, she'll say our greeting.
Now we need to grab that variable, and we'll bring it down over here,
put it inside the slot, and click on it.
And there you go. Ada's saying hello, world.
What is happening here? I created a global variable
by selecting the for all sprites button.
As the dialog box implies, this means that every sprite will have access
to the information bound to this variable.
After giving it a name, I see that the greeting appears
near the top of the variable's palette.
What is the value of the variable when it's first created?
If you look closely, you saw that it was zero.
In NIST blocks, all variables begin life with a value zero.
If you want to change that assignment, then you need to use a set to block,
like we did to bind the variable to a new value.
In this case, I set the value to hello, world.
And now the variable is available to me anywhere in the project.
Actually, it's available across all sprites in the stage,
but not on peer-to-peer networks.
We'll talk about how to communicate information across networks
in an upcoming video.
Notice the gray and orange block at the upper right of the stage.
That's called a variable watcher.
It's used to keep track of the values bound to variables.
Watchers prove useful, especially when you're seeking to debug variables.
That is to understand why your variable does not have the value
that you expect it should have.
But sometimes those watchers just take up space in the stage,
and if you have too many variable watchers,
the stage can be cluttered with orange boxes.
To toggle them on and off, just click the checkbox
besides the name of the respective variable
near the top of the variable palette.
And voila, it's gone.
Since this is a global variable,
all my other sprites and code blocks have access to it.
So if I want to create another sprite,
that sprite can also use the variable to greet us.
So let's do that with Alonzo.
So I need to create another sprite.
I'm going to do that by clicking here, and there's the sprite.
It comes in as an arrow or the turtle.
And now if I want to give it a costume, I can do that.
So let's say up here we're going to give it a costume.
It takes a moment to open the costumes.
There's Alonzo.
Bring it in.
Close.
Let's bring Alonzo a little bit further up.
Now we want Alonzo to say hello to us too.
So I'm now coding within the Alonzo sprite.
So here I'll just bring over the looks,
and I'm going to save for two seconds,
and I can go back and grab that same variable here, greeting,
put it in there.
Now, since I'm inside of Alonzo, when I click on this,
you'll see that it'll be Alonzo that says our greeting.
There you go. Hello, world.
I didn't have to redefine it, though,
because it's a global variable.
It's available to all the sprites.
Notice that I did not need to set the value of the greeting again.
I could just use it in the scripting area of the Alonzo sprite.
However, if I create a variable for the sprite only,
then only Alonzo can use it.
If I set the value of goodbye, for example, to farewell,
you'll see that its watcher prefaces the name of the variable,
and a pin appears in front of the name of the block on the variable palette.
Let's give that a try.
So I'll go now create another variable,
and we'll call it goodbye,
but I'm going to make it for this sprite only.
There we go.
And now you see here that sprite2,
and let's give it a better name so we know who it is.
Let's see. Sprite2 should be called Alonzo.
Okay, so now this variable is set only for Alonzo's use.
So here we can set this, and we can then change this goodbye to goodbye.
Let's just call it goodbyeAda.
There we go.
Now it's set to goodbyeAda,
and here we can have Alonzo say that for us.
So actually I'll just use this block right here,
and we'll bring in that variable this time,
and say goodbye.
GoodbyeAda.
Now I'm going to get rid of this from the stage so you can see better,
but if I move back to Ada and I try to use that variable,
you see it's not available to me because it's private now,
or its scope is only the Alonzo sprite.
We can create a sprite variable with the same name for pixelAda,
and it will not step on Alonzo's toes.
So we can have Ada, for example, say goodbye to Alonzo.
Let's do that.
So since there's no goodbye here,
I can just say make a variable for this sprite only,
call it the same thing, goodbye,
but this will be Ada's goodbye.
And now I can set the value of Ada's goodbye to goodbyeAlonzo.
Here we go, we want to say goodbye.
Set it.
Take it off the screen.
We'll say it.
Oop, that's the greeting.
Say goodbye now.
And you see goodbyeAlonzo.
If we switch back to Alonzo, goodbye, Ada.
They don't step on each other's toes.
But wait, we're not ready to say goodbye yet.
There are still a couple other variables we need to cover.
We saw how to keep variables private to sprites,
but did you know that you can also keep variables private
to stacks of blocks as well?
In fact, there are two ways to do this.
The first is to create a script variable.
You can find the script variable block on the variable palette here.
You can see it right here, script variables.
If you drag this block over,
you can connect it with other blocks in the stack,
and those other blocks will be able to use that variable.
Let's try this out with a simple mathematics example.
I'm going to make a stack of blocks that prompts the user for two numbers,
assigns those numbers to script variables,
and then uses those script variables for calculating the answer.
All right, so let's create two script variables.
You can click this arrow to make two at once,
and I'm just going to call this num1, okay,
and then num2.
And here we'll set...
You notice if I drop down here, I've got them, num1,
and we're going to set num2.
Let's set this one to 5, and let's set this one to 7,
and then we can report...
those two variables.
We need an operator here to add them together.
Here we go.
Grab this one, num1.
Grab this one, num2.
And you should expect that this will report 12,
and indeed it does.
After the stack of blocks has finished executing,
the two script variables go out of scope.
Those variables are no longer available in our program
unless we click on this stack of blocks again.
If we do so, they are reinitialized with values of 0
as if they had never previously existed.
Let's talk about the last type of variable,
namely block variables.
Block variables are essentially similar to script variables.
You create block variables when making custom blocks,
and as their name suggests, they remain in scope
only for the scope of your custom block.
Block variables are subtly hidden
within the user interface of Nets Blocks,
so let me show you how to find them.
We'll create a counter using a custom block.
To do this, we'll create a custom block called incrementSum,
and let's just go ahead and start doing that now.
So I'll right-click here and make a block.
I'm going to have it be an operator and a reporter
called incrementSum.
Say OK. There it is.
If you right-click here, you'll see block variables pop up,
and then there's a drop-down arrow.
If you squint, you might miss it.
You click on that, and you'll see block variables appear,
and then, like before, you can click on that
and give a name to your variable.
If you need more, you can use those arrows to do that.
So here's what I'll do.
I'm going to bring a control block down.
Oh, under variables, I'll use a set block here.
Put it there.
I'm going to set sum to the value of sum plus 1.
And then I'm going to report.
Here we are.
I'm going to report the value of sum.
OK.
The first time you click on the increment block, it reports 1.
Why?
Well, the default value of the variable is 0,
so the block reports 0 plus 1, which is 1.
But now let's click on the block again, and we get 2.
If we click again, the answer is 3.
If we click it again, the answer is 4.
So what's going on here?
The answer is that block variables, unlike script variables,
retain their value after the custom blocks finish executing.
If you use a script variable, by contrast,
it gets reset to 0 the next time the stack of blocks runs.
So a block variable remembers its value,
and you can use it to store information for later computations.
This can come in handy if you want to keep track of the name,
for example, of a player or of the high score in a game.
OK.
So that's it for today.
We've learned about four different types of variables in Nest Blocks,
global variables, sprite variables, script variables, and block variables.
Which should you use for your project?
Well, circumstances vary.
In general, you should create variables with as limited a scope as possible.
New programmers like to work primarily with global variables
because they're so easy to use,
but you'll find that most experienced programmers tend to eschew them
in favor of sprite, script, or block variables.
What matters at this point is that you understand the concept of variables,
how to create them and to bind them to values,
and also know how to tell when they're in or out of scope.
Thanks, everyone.
I look forward to seeing you again in our next video.
</p>
  

    <h2>25. weather</h2>
    <p>Hi, everyone.
Welcome back to Programming for a Network World.
Today, we're going to continue our exercise with mapping.
We're going to explore now how to put a map on the stage,
and then from there, how to display the weather
condition for any part of the country you're interested in.
All right, so ready to find some icons to display the weather?
Let's get going.
So let's get started by just creating a map again
like we did before.
So I'm going to go over to our RPC here under Network,
and I'm going to bring out this call block.
I'm going to switch it down to Google Maps,
and I'm going to then get map.
And let's do the latitude and longitude
just for where I am again.
So as you remember, the way that we do that,
we can go over here to Sensing, and we can drop down
to My Latitude, drop it in here, My Longitude over here,
then the Height there.
Let's try that again.
The Height there, and the Width, the Stage.
There we go.
This one is over here, so we'll just throw it away.
And we'll set a zoom of, let's just say, 11.
Get some of the surrounding area.
Now, remember, we need to go over to Looks,
switch to Costume, and we're going to drop this in there.
OK, so now I'm just going to give a little more space here.
OK, let's try this out.
And there's our map.
If I went a little bit too quickly there,
go back and review the other video,
because that's where we covered how to create these maps.
OK, so now that we've got a map, our goal today
is for us to be able to click on any part of this map
and then get an icon representing
the current weather conditions in that part of the map.
So if you think about what we need to do,
we need to trap a position using our xy-coordinate
of the stage.
And then we need to convert that xy-coordinate
into a latitude and longitude that we
can pass to some kind of weather RPC.
Hopefully, that exists.
It actually does in Nets Blocks.
And then we'll find an icon to represent the weather.
If that sounds complicated, it might
be using other programming languages.
But fortunately, there are tools within Nets Blocks
to make that process much easier.
So let's begin by thinking about how to get the xy-coordinates.
So let's try going to our RPCs to see if there's
anything that can help us here.
So I'm going to go down here.
And let's go back to Google Maps.
All right.
And let's look at our list of options again.
Now, when you look at the list of options, you see here,
get latitude from y and get longitude from x.
So that's exactly what we need.
We need to be able to click on an xy position
and then translate that into the latitude and longitude
of the map that we're looking at.
So let's just go ahead and try that out.
We're going to get latitude from x or latitude from y.
And I'll duplicate this here.
And get longitude from x.
So here is their x and y positions.
Now, we can give the information about where our x and y
is by going to the sensing block here
and saying mouse x and mouse y.
So let's just say mouse x and mouse y.
Now, we can click on it.
Oops.
Here.
Let's try that.
There we go.
And you see that it is now giving us those positions.
They're not the positions that we want,
because it's trapping where our mouse is actually
in the scripting area rather than on the stage.
But we'll get to that in a second.
So that's great.
That's actually the information that we need to pass
in to get our weather icon.
But how do we get the icon itself?
So let's go back to look at our list of RPCs here.
I'll bring this over again.
And let's drop this down.
And there's a section called Science here
that has a lot of information that
has to do with various different types of measurements,
historical trends.
We've looked at these before when we were doing our chart
RPC.
But if you look down here, you see under Science,
you also see Weather.
And so if we look now at what's possible for weather,
we see we've got a number of options.
We've got a description, humidity icon, temperature,
wind angle, speed.
So let's go for Icon.
And you see it does come with a latitude and longitude.
So now we can drop these blocks in here.
This is the latitude.
So let's drop that in there.
And this is the longitude.
And if we click on it, we get a cloudy icon.
Now, it's a little bit hard to tell what is cloudy,
because, again, we're trapping a XY position that's
on the stage, on the scripting area, excuse me,
rather than the stage.
And so we actually need to now look
to see where on the map that's on the stage
we can get a weather icon.
So let's think about how to do that.
Here, I think it's a little bit tricky.
We need to think about when you're
interacting with this map, a user will be on the map
and then click at some point in the map like this.
And then we want to trap that click,
then pass in the XY position of the place
that the person clicked on the map.
And then we want to translate that
into the corresponding icon for the current weather
conditions.
So I think the best way to do this
is to split between we're working right now
on the scripting area, but I think
we should split our project into using a stage and a sprite.
And so what I'm going to do is take this
that we've done here, this initial mapping setup,
and I'm going to move it over to the stage.
So I can just move it like this.
And it actually duplicates.
You can see that I still got a copy here,
but I'm going to throw that away.
And that's because if I go to the stage,
you'll see now that I've got a copy there.
So that's good.
And let's go up here and just kind of get
a when green flag clicked.
So we'll do that over here.
There we go, to start the project.
And now we want to trap here.
Anyone who clicks on the stage, we
want to kind of trap that event.
So you know when we're talking about events
that one way to capture them is to use a broadcast block.
So we're going to do this.
We're going to go over to when I am clicked.
So this is an event.
And then we're going to broadcast
that that event has occurred.
That way, we'll be able to capture that event
in our sprite, which is where we'll do our icons for the weather
conditions.
OK, so we'll just make this a very simple broadcast.
So I'll do that here.
And I'm going to say new.
And let's just call it look up weather, say.
So when this is clicked, it will look up the weather.
But we have nothing yet that will handle that broadcast.
So there's nothing here in our sprite
that will actually handle that.
So now we need to think, OK, when I receive this message,
what do I do?
So first of all, let's just start off with when I receive.
And if we drop down here, we can say look up weather.
So when I receive look up weather,
then I need to do something.
Now, we need to move to the xy position where the mouse is.
So let's do that.
Let's go to motion.
And we'll move to here.
Go to the xy position of the mouse.
So let's do that here.
Let's see, xy, there we go.
Mouse x and mouse y.
And then we're going to display the weather.
So same way that we need to get it onto the stage,
we're going to switch to that costume.
But this is now the sprites costume, not the stage.
And so let's do that.
We're going to go to looks.
Switch to costume here.
We're going to drop this into there.
Now, we've got our mouse x and mouse y.
So that's good.
OK, now the only thing that we need to do
is to draw that icon on this part of the stage.
The easiest way to do that is to use some
of the tools that come with Pen.
So here, we're going to go to stamp.
And all right, we'll stamp that particular icon
at that position on the stage.
So let's give it an initial try and see how it works.
So we start it.
I'm going to click here.
Let's see, are we handling the event yet?
OK, there we go.
Let's see.
Now, click there, click there, click there.
OK, so that's not working yet.
Let's go and see what is going on with our program here.
OK, when I receive lookup weather, go to X, Y, Z.
OK, when I receive lookup weather, go to X, Y position,
switch to costume.
Let's just make sure this is working here.
Yep, that looks good.
And then stamp, so there we go.
OK, so let me start this from scratch.
Now, you notice when I start from scratch,
I'm still leaving those icons on the stage.
So we actually want to remove them whenever
we hit the green flag click.
So let's do a little bit of setup here.
So let's go over to the stage here.
And when we first start up, we're
just going to hit Clear, OK?
So here, we'll just say, when green flag is clicked,
clear the stage, so just get rid of any of the icons
that had been there before.
And then we'll start from scratch.
And the other thing is, I think we want to also, well,
let's try it.
OK, so we're going to start it.
And there we go.
We're able to click and see the conditions around us.
But there's one problem.
You notice when we started here, we still
had one icon that was left over.
And that's because the sprite is still showing on the stage.
So one way to do that is to set it up
so that when we run this, we show the sprite,
and then we hide the sprite.
So let's do that here.
And let's go over to Show and to Hide.
And this will mean that we first show the sprite, we stamp,
and that leaves this permanent imprint of where
the sprite is on the stage.
And then we hide the sprite again
so we don't have that problem of a lingering weather
condition that persists past the beginning of the program.
All right, so let's try that one more time.
Can I click Stop, and then we'll hit Run.
And this first time, I guess it's still left there.
So let's try it again now because it should be hidden.
So I'm going to click this, Run.
You see things are gone now.
The sprites aren't showing because we've
hidden them right here.
And now we can test this out again.
So this should be the full program.
Let's just bring this out all the way.
And let's see how things are in Nashville today.
So downtown Nashville is cloudy.
Up by Vanderbilt, probably also cloudy.
Yep.
We could set our initial starting point.
Let's just go to the stage here, and let's
zoom out a little bit more.
Let's try, like, I don't know.
How about five?
And we'll click on that.
We'll get the new map.
Give it a second for the map to show.
There we go.
Now we're getting a much broader geographic area.
So let's try the same thing.
We'll look at various cities around.
So Nashville, again, should be cloudy.
But how is Indianapolis?
Partly cloudy, I guess, is what that means.
Washington, DC, cloudy at once.
Cloudy day all around.
How about Georgia?
Same thing.
How about Louisiana?
Wow, same thing.
All right, it's sunny as you head out to the Midwest.
OK, so that's it for today.
So just to recap, what you saw was that we can create a map.
And then by trapping the interaction with the map,
where we clicked with our mouse XY coordinates,
we can translate that into latitude and longitude
and pass that to another RPC that then gives us
information about the weather conditions
in that particular region of the map.
We'll continue with mapping next time.
So I look forward to seeing you in our next video.
</p>
  

    <h2>26. welcome-to-NetsBlox</h2>
    <p>Hi everybody, my name is Cliff Anderson. I'm a librarian at Vanderbilt University
and a member of Vanderbilt's Computational Thinking and Learning Initiative.
This short video is a preface to my introduction to programming with Netsblocks.
Netsblocks is a visual programming language that makes it easy and fun to learn to program,
and Netsblocks allows you to do pretty advanced things like peer-to-peer networking and making
remote procedure calls. This series will start with the basics of programming in Netsblocks
and step-by-step, video-by-video, teach you what you need to write some really advanced code.
Just like you see in the preface to a book, I'd like to start by giving credit to the people and
organizations on whose work I'm building. To begin with, I'd like to thank the developers
of the Snap programming language. Snap is a block-based programming language developed
at the University of California, Berkeley that borrows from the visual vocabulary of Scratch
but draws inspiration from the semantics of Scheme. The primary developers of Snap are Jens
Munich and Brian Harvey. Netsblocks builds on Snap, extending its functionality. If you want
to check out Snap for yourself, visit snap.berkeley.edu. A lot of what I teach in this course will
work in Snap as well as in Netsblocks. If I'm doing something that only works in Netsblocks,
I'll make sure to flag that for you. Second, I'd also like to thank the developers of the Beauty
and Joy of Computing curriculum. The Beauty and Joy of Computing teaches the fundamentals of
computer science at both the high school and college level with an emphasis, as the name
suggests, on aesthetics and playfulness. I'd encourage you to check out the curriculum online
at bjc.berkeley.edu and especially to watch Dan Garcia's TEDxBerkeley talk on the origins and
principles of the BJC. I myself have taught the Beauty and Joy of Computing to undergraduates
at the School of Engineering at Vanderbilt University. If you want, you can check out my
curriculum online on github.com. What I teach during this video series is not a
one-to-one port of that course, but it certainly draws inspiration both from the BJC and from my
experience teaching undergraduates at Vanderbilt. Finally, I'd like to thank my colleagues at
Vanderbilt who have developed Netsblocks, most particularly Akos Ledeshi, professor of computer
engineering at Vanderbilt University and principal investigator of Netsblocks, as well as Brian Broll,
research scientist at Vanderbilt and lead architect of the Netsblocks software. Last but not least,
I'd like to credit the use of Alonzo, the friendly sprite modeled on Gobo from scratch.
The difference is in the tail. Do you see how Alonzo has a forked tail? We'll get to why there
is that difference later in this course. For now, let me thank the creators of Gobo and Alonzo for
making this cute sprite to accompany us on our programming journey. Ready to learn how to program?
Check out the next video in this series and let's get started together.
</p>
  

    <h2>27. what-is-blocked-based-programming</h2>
    <p>Hey everybody, my name is Cliff Anderson, and I'm a librarian at Vanderbilt University.
I'm also a member of a research group called the Computational Thinking and Learning Initiative.
In this series, I'm going to introduce you to the fundamentals of programming using a
state-of-the-art tool developed at Vanderbilt University called NetsBlocks.
NetsBlocks makes it easy to get started by cutting down the number of mistakes you can
make.
And by reducing the chance for error, it will help you focus on the important stuff.
So ready to get started with block-based programming?
Stick around.
This series is about learning to code using a development environment called NetsBlocks.
If you're new to programming, the choice about where to begin can be overwhelming.
There are so many options to consider, from C to JavaScript to Python and beyond.
These languages are very different, but they all share one thing in common, namely they
are text-based languages.
That is, you write code by typing out instructions on the screen.
Typing out instructions serves most expert programmers well.
You can express a lot of complex ideas in very terse statements and expressions.
Most software engineers aim to write more like Gertrude Stein than Henry James.
That is, they aspire to conciseness over verbosity, although they can be elliptical at times.
But textual programming languages prove challenging for newcomers.
How do you know what commands to type when you're first getting started?
We're all familiar with the idea of writer's block.
That is, the panic of seeing a white page that you need to fill up with words.
What should I write?
The same kind of thing happens when you're programming in textual languages.
If I want to draw a circle on the screen, what commands do I need to type in?
If you're learning a programming language like Python or JavaScript, you'll need to
look up those commands in the documentation, or more likely Google it and then copy and
paste your solution.
And what happens if something goes wrong?
Like maybe you dropped a parenthesis when copying your code into your text editor.
Well, your code editor will try to highlight your mistake, just like a Word doc.
A code editor may not always be able to pinpoint your mistake as easily.
It basically just says, hey, something happened by the time I reached this line, and now I
don't know how to go further.
Your experience may vary by language, but tracking down a syntax error can take a surprising
amount of time.
And how do professional programmers fix these syntax errors?
Well, they Google the problem, checking out sites like Stack Overflow to read how other
programmers have fixed the issue before them.
So here I've got a JavaScript window in front of me.
This is a cool site called Repl.it that allows you to program in many different languages.
And so I'm just going to start off here and, you know, to begin with, what do I have to
type?
All right.
I'm going to write a program here that's going to say hello to me in JavaScript.
So here we go.
Let's just write this out.
So I'm going to have to say function hello.
We're going to give it a parameter called name.
Then I'm going to put in a curly brace, and then I'm going to console.log, say hello comma.
And then after the quotation mark, I'm going to put a plus symbol, and then I'm going to
put the name that gets passed in with a semicolon.
And then I drop down a line, and let's call that function, so we're going to say hello
clip.
And my name is in quotation marks, and then I put a semicolon at the end, and let's run
it.
And sure enough, it says hello clip.
So it worked.
But hey, look what happens if I just take off this ending parenthesis.
Get like a bunch of red marks here.
There's some squiggly lines.
Let's see what they say.
So this particular line here says TypeScript, comma is expected.
Not sure if I needed a comma there.
Here it says another comma is expected, but that's actually a period.
Another comma seems to be expected.
So a lot of commas seem to be expected.
It says declaration of statement expected.
I'm not even sure what that is.
So you can see there are a lot of errors, but it's not entirely clear how you're supposed
to fix those errors.
Now we could go into Google and see this, but it's, as you know, I just dropped a paren.
And everything's back, and if I run this again, hello clip.
It works fine.
The point is, it takes some experience to learn how to read errors, and it's easy to
make errors, which is kind of a bad combination, because when you're a beginner, you make a
lot of errors, and then you don't know how to fix them.
So let's switch over now to NetsBlocks.
The purpose of a blocks-based programming language is to lower the barrier to entry,
and to make it easier to program without having to Google everything.
Here's the interface for the NetsBlocks programming environment that we'll be exploring during
this series.
As you see, there are these nice sets of blocks along the side, and each of the blocks in
this palette represents a unit of computation.
You program in NetsBlocks by selecting blocks and then snapping them together with other
blocks in the coding area.
That's this area right here.
We'll see the results of the computation either in the coding area or on the stage.
This is what we call the stage.
The guiding metaphor for NetsBlocks is Lego bricks.
NetsBlocks is designed to help you to program without running into those indecipherable
error messages.
In general, if the blocks snap together, your program will work, although it may not always
produce the results that you expect.
The cool thing about NetsBlocks and other block-based programming languages is that
you can play around with stacking these blocks just by moving them onto the scripting area
and building bigger and bigger blocks.
So if you ever have programmer's blocks, just try dragging some new things on and seeing
what they do.
You see, they stack right there, and then you can test them out just by clicking on
them.
I'm going to end this short video with another example of Hello World.
We're going to ask our mascot, Alonzo, to help us out a lot during this series.
So this time we're going to recreate our Hello World program in NetsBlocks.
And we'll do this by exploring the palette and finding the different blocks that we need
to get Alonzo to say hello to us.
So the first thing that we need is this Say Hello block.
Here's Alonzo, and we want him to say hello to us.
So if we click Say Hello, Alonzo says hello.
But we don't quite yet have our name, right?
So the next thing is, how will Alonzo know our name?
So let's go here to Sensing, and let's grab Ask What Is Your Name? and wait.
And then there's another block that has the answer.
So let's try this.
Ask What Is Your Name?
A little box pops up, and we can input box, and we can put in my name here.
Oh, it didn't say hello to me.
Why is that?
Well, here's the answer.
Cliff, we need to put it into our computation.
We haven't done that yet.
So how do we do that?
Well, OK.
So let's take a look here.
Maybe we need another operator.
And we're just going to do this, called Join.
And you see it says Hello World.
But I'm going to put my name in, and then we're going to drop this right inside that
slot.
OK, let's try it again.
So here we go.
Alonzo says, what's your name?
I put in Cliff, and it says, hello, Cliff.
So that's a short example of a block-based program.
We're going to get into really deep and complex examples.
A lot of people say, like, block-based programming is just a beginner's programming language.
It's like programming with training wheels on.
But you're going to see throughout this course that that's definitely not the case.
In fact, block-based programming allows you to get into much more complex ideas and concepts
than you would have in many other programming languages, or that you would be able to reach
in other programming languages without a lot of experience.
But the thing is, it makes it friendly and accessible and fun to program.
And that's the most important thing.
We're here to have fun as we learn.
So I invite you to stick around for the series on block-based programming.
And let's see how far we and Alonzo can take you on this journey.
Thanks for joining me, and see you next time.
♪♪♪
</p>
  

    <h2>28. zip</h2>
    <p>Welcome back to Programming for a Networked World.
Today we're going to be continuing our exploration of the chart RPC.
But I'm going to let you in on a little secret.
Last time we had nicely formatted data,
a list of lists that we passed into the chart EPC, RPC,
and then got back a good graphic.
But your data doesn't always come nicely packaged as a list of lists.
So what do you do then?
We're going to learn how to apply our knowledge of how to work with lists
so that we can format our data in a way that makes it easy to chart.
Let's get started.
Okay, so here's our plan.
We're going to look at the difference between linear growth and exponential growth.
And we're going to do that by combining two lists.
A list of numbers, just say 1 to 15,
and then those numbers either multiplied by 2 or squared.
But to do this, we need to combine two lists.
The first list of our initial numbers,
and then the list of those numbers with the mathematical function applied to them.
Okay, so how do we do that?
Well, to get started, we can just make a list of lists.
So that's easy enough.
We'll go down to our lists here and let's take a look.
There's numbers 1 to 10.
If we click on that, we get 1 to 10.
Let's just change it 1 to 15.
There we go.
And now how do we get the list of numbers with the function applied?
Well, that's also fairly easy to do here
because we can take one of these blocks here that's like square root,
and we can drop down and we can find, for example, 2 times.
Here we go.
And if we pass that in,
you see that it automatically applies that function to every item in the list.
So that's great.
We have now our list of numbers 1 to 15,
and then we have the squares from 1 to 15,
and we can do the same thing, of course,
if we come over here and we get the multiply by 2.
Let's do that.
So we'll say 2 times, and then we're going to make a copy of the numbers.
We'll duplicate that.
And again, it produces a nice list for us of those numbers multiplied by 2.
The trouble comes in when we want to actually combine these lists
because, as you know, the chart RPC requires us to pass in a list of lists.
And here we have two single lists side by side.
So we need to combine them.
And this operation in programming speech is called zipping the lists.
That is taking one list and another
and making a list out of a list or a matrix out of them.
So how do we go about doing that?
Well, let's develop a block that will help us.
We're going to call this block join.
All right, so let's just create a new block here.
And we're going to call it join.
And it's going to be a reporter.
So we're just going to say join, let's say, list 1 and list 2.
So now, and maybe we'll call it join list just to be clear that it's not joining strings.
And we're going to turn that to reporter,
and we're going to put it into the operations category here.
And now we're going to take that and make it an input.
And the input type is going to be a list.
And that's good.
I'm going to say okay.
Here we go.
And here, do the same thing.
I'm going to make that a list.
Say okay to that.
Okay, so there's the block that we'll be working with.
And now, how do we start putting these together?
Well, first let's create a variable called matrix.
So let's see, under variables here, we'll make it a script variable
because we just want to contain it within the block.
Call it matrix.
There we go.
And now we're going to iterate through the length of this list.
And then we're going to, for each item in one list,
we'll add the second item, and then we'll send back a combined list.
Now the trick is you should make sure that the lists going in here are the same length
because if they aren't, you might have unexpected results.
We're going to assume for the sake of this demonstration that they are.
Okay, so we'll just take a loop here.
We'll say like a for loop.
And here we go.
And we'll say from 1 until the length of list 1.
And now what do we do?
Well, we want to combine those lists.
So we're going to make a new list,
and we're going to use this add function here.
Find it down towards the bottom.
There we go.
And what we're going to add is a list
because this is a list of lists,
so we're going to add a list right here
like that with two slots.
And we're going to take item 1 of the first list
and item 1 of the second list.
But of course, we don't want it to be item 1 each time.
That would make the list of only the first items.
We want it to be item i and item i of the first list
and of the second list.
And then we're going to assign those to matrix.
Now, the only other thing that we need to remember is
we need to make sure that matrix is given the type of a list
so that when we first assign lists to it,
the compiler doesn't complain,
or the interpreter, I should say, doesn't complain.
Okay, so let's do that.
And here we're going to set under variables matrix
to an empty list.
That'll help us get started.
All right.
So this operation, again, is called zipping a list,
and let's see if it works as we expect.
So I'll say done, and we'll go to custom blocks here.
I'm going to grab this join list,
and now let's get our numbers from 1 to 10.
So we'll duplicate this.
And again, it's 1 to 15, I should say.
That's fine.
So we're going to pass that in as the first list,
and then let's do this one,
which are the squares of those numbers,
as the second list.
There we go.
And let's try it out.
And okay, we're getting an error.
So let's take a look.
Set matrix to list for i equals 1 to length of list.
Oh, this needs to be the length of list 1.
All right, let's do that.
Let's go under lists here
and get the length of because there we go.
Not just the list, but the length of the list.
And now we didn't get a report.
Let's go check out what's going on here.
Ah, yes.
It would be helpful to add a report to the list at the end.
So let's do that.
All the simple things we need to remember
when we're making blocks.
All right, so let's get our report here,
which should be...
There we go.
Report.
Okay.
And now we're going to report the matrix.
And that is, in fact, what our chart service needs.
So if we go back out to our chart service,
we can go here to network.
Let's bring over our chart.
Drop down.
And we're going to just do the draw.
And remember, we discovered we don't need default options
if we're just going to keep the options in place.
And we can take this here as our lines.
And we'll have to say goodbye to eta,
but because we want to plot this on the screen,
we're going to put that switch to costume there.
There we go.
And let's try it out.
There we go.
So that is a chart of exponential growth.
And if we want to do a similar chart of linear growth,
it would just be a question of changing
this particular function right here.
We'll put that two times in here.
And let's look at the difference between exponential
and linear growth.
And there you go.
So that's a linear function as opposed to an exponential one.
Okay.
So the main thing is those zipping operations
are things that you're going to run into all the time
if you need to chart, because you always need something
for the x-axis and another list for the y-axis.
Now, I'll let you in on yet another secret.
If you don't want to write those zipping functions yourself,
Brian has already written one for us.
And you can find this under here.
If you go to Libraries and you click on Libraries,
and then this is a tab that we haven't used before.
It's called Community.
And community libraries are libraries that are provided
by members of the NetSplocks community,
and you can access them here.
And so if you look and we type in zip,
you can see that there is a zip library.
And if you drop down, you can see that it has
a function called zip.
So let's try this out.
We're going to substitute the zip function that we've written,
which is join list here, and let's use Brian's.
So in this case, you see that it takes a single list,
but we need to expand it to contain two.
We're going to drop our numbers in here.
There's the first slot.
And then we want to drop this function into the second slot,
and let's see if it produces a list.
There it does.
That's our linear list.
Let's do the exponential one.
There we go.
We'll click on that, and you can see that it works
in exactly the same way.
Now, if you look under the covers,
the operations are different.
I'll leave that to you to explore how Brian
has implemented this function.
But let's just drop it back for completeness sake
into our charting operation and see if it works.
It needs to go into the line slot, not into the options.
Let's switch to costume, and there we have it.
Okay, so in this video, you learned what zipping a list is.
It's taking a list of numbers and another list of numbers
and then combining them into a matrix.
And you learned that you need to do that
when you want to chart operations in which you need
to have an x-axis and a y-axis.
And you also learned a little bit about how you can use
community-contributed libraries like Brian's
if you don't want to write those kind of functions yourself.
Although, that's the fun of programming, of course.
All right, that's it for today.
I look forward to seeing you in our next video.
</p>
  
	</body>
</html>
